// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `terra/oracle/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct QueryExchangeRateRequest {
    // message fields
    pub denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeRateRequest {
    fn default() -> &'a QueryExchangeRateRequest {
        <QueryExchangeRateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeRateRequest {
    pub fn new() -> QueryExchangeRateRequest {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryExchangeRateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeRateRequest {
        QueryExchangeRateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "denom",
                |m: &QueryExchangeRateRequest| { &m.denom },
                |m: &mut QueryExchangeRateRequest| { &mut m.denom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryExchangeRateRequest>(
                "QueryExchangeRateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryExchangeRateRequest {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeRateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeRateRequest::new)
    }
}

impl ::protobuf::Clear for QueryExchangeRateRequest {
    fn clear(&mut self) {
        self.denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryExchangeRateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeRateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryExchangeRateResponse {
    // message fields
    pub exchange_rate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeRateResponse {
    fn default() -> &'a QueryExchangeRateResponse {
        <QueryExchangeRateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeRateResponse {
    pub fn new() -> QueryExchangeRateResponse {
        ::std::default::Default::default()
    }

    // string exchange_rate = 1;


    pub fn get_exchange_rate(&self) -> &str {
        &self.exchange_rate
    }
    pub fn clear_exchange_rate(&mut self) {
        self.exchange_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchange_rate(&mut self, v: ::std::string::String) {
        self.exchange_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exchange_rate(&mut self) -> &mut ::std::string::String {
        &mut self.exchange_rate
    }

    // Take field
    pub fn take_exchange_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exchange_rate, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryExchangeRateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exchange_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.exchange_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.exchange_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.exchange_rate.is_empty() {
            os.write_string(1, &self.exchange_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeRateResponse {
        QueryExchangeRateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exchange_rate",
                |m: &QueryExchangeRateResponse| { &m.exchange_rate },
                |m: &mut QueryExchangeRateResponse| { &mut m.exchange_rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryExchangeRateResponse>(
                "QueryExchangeRateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryExchangeRateResponse {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeRateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeRateResponse::new)
    }
}

impl ::protobuf::Clear for QueryExchangeRateResponse {
    fn clear(&mut self) {
        self.exchange_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryExchangeRateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeRateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryExchangeRatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeRatesRequest {
    fn default() -> &'a QueryExchangeRatesRequest {
        <QueryExchangeRatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeRatesRequest {
    pub fn new() -> QueryExchangeRatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryExchangeRatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeRatesRequest {
        QueryExchangeRatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryExchangeRatesRequest>(
                "QueryExchangeRatesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryExchangeRatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeRatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeRatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryExchangeRatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryExchangeRatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeRatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryExchangeRatesResponse {
    // message fields
    pub exchange_rates: ::protobuf::RepeatedField<super::coin::DecCoin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeRatesResponse {
    fn default() -> &'a QueryExchangeRatesResponse {
        <QueryExchangeRatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeRatesResponse {
    pub fn new() -> QueryExchangeRatesResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.v1beta1.DecCoin exchange_rates = 1;


    pub fn get_exchange_rates(&self) -> &[super::coin::DecCoin] {
        &self.exchange_rates
    }
    pub fn clear_exchange_rates(&mut self) {
        self.exchange_rates.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchange_rates(&mut self, v: ::protobuf::RepeatedField<super::coin::DecCoin>) {
        self.exchange_rates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exchange_rates(&mut self) -> &mut ::protobuf::RepeatedField<super::coin::DecCoin> {
        &mut self.exchange_rates
    }

    // Take field
    pub fn take_exchange_rates(&mut self) -> ::protobuf::RepeatedField<super::coin::DecCoin> {
        ::std::mem::replace(&mut self.exchange_rates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryExchangeRatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.exchange_rates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exchange_rates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.exchange_rates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.exchange_rates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeRatesResponse {
        QueryExchangeRatesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::coin::DecCoin>>(
                "exchange_rates",
                |m: &QueryExchangeRatesResponse| { &m.exchange_rates },
                |m: &mut QueryExchangeRatesResponse| { &mut m.exchange_rates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryExchangeRatesResponse>(
                "QueryExchangeRatesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryExchangeRatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeRatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeRatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryExchangeRatesResponse {
    fn clear(&mut self) {
        self.exchange_rates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryExchangeRatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeRatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTobinTaxRequest {
    // message fields
    pub denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTobinTaxRequest {
    fn default() -> &'a QueryTobinTaxRequest {
        <QueryTobinTaxRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTobinTaxRequest {
    pub fn new() -> QueryTobinTaxRequest {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTobinTaxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTobinTaxRequest {
        QueryTobinTaxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "denom",
                |m: &QueryTobinTaxRequest| { &m.denom },
                |m: &mut QueryTobinTaxRequest| { &mut m.denom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTobinTaxRequest>(
                "QueryTobinTaxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTobinTaxRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTobinTaxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTobinTaxRequest::new)
    }
}

impl ::protobuf::Clear for QueryTobinTaxRequest {
    fn clear(&mut self) {
        self.denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTobinTaxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTobinTaxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTobinTaxResponse {
    // message fields
    pub tobin_tax: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTobinTaxResponse {
    fn default() -> &'a QueryTobinTaxResponse {
        <QueryTobinTaxResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTobinTaxResponse {
    pub fn new() -> QueryTobinTaxResponse {
        ::std::default::Default::default()
    }

    // string tobin_tax = 1;


    pub fn get_tobin_tax(&self) -> &str {
        &self.tobin_tax
    }
    pub fn clear_tobin_tax(&mut self) {
        self.tobin_tax.clear();
    }

    // Param is passed by value, moved
    pub fn set_tobin_tax(&mut self, v: ::std::string::String) {
        self.tobin_tax = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tobin_tax(&mut self) -> &mut ::std::string::String {
        &mut self.tobin_tax
    }

    // Take field
    pub fn take_tobin_tax(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tobin_tax, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTobinTaxResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tobin_tax)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tobin_tax.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tobin_tax);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tobin_tax.is_empty() {
            os.write_string(1, &self.tobin_tax)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTobinTaxResponse {
        QueryTobinTaxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tobin_tax",
                |m: &QueryTobinTaxResponse| { &m.tobin_tax },
                |m: &mut QueryTobinTaxResponse| { &mut m.tobin_tax },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTobinTaxResponse>(
                "QueryTobinTaxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTobinTaxResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTobinTaxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTobinTaxResponse::new)
    }
}

impl ::protobuf::Clear for QueryTobinTaxResponse {
    fn clear(&mut self) {
        self.tobin_tax.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTobinTaxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTobinTaxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTobinTaxesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTobinTaxesRequest {
    fn default() -> &'a QueryTobinTaxesRequest {
        <QueryTobinTaxesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTobinTaxesRequest {
    pub fn new() -> QueryTobinTaxesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryTobinTaxesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTobinTaxesRequest {
        QueryTobinTaxesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTobinTaxesRequest>(
                "QueryTobinTaxesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTobinTaxesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTobinTaxesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTobinTaxesRequest::new)
    }
}

impl ::protobuf::Clear for QueryTobinTaxesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTobinTaxesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTobinTaxesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTobinTaxesResponse {
    // message fields
    pub tobin_taxes: ::protobuf::RepeatedField<super::oracle::Denom>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTobinTaxesResponse {
    fn default() -> &'a QueryTobinTaxesResponse {
        <QueryTobinTaxesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTobinTaxesResponse {
    pub fn new() -> QueryTobinTaxesResponse {
        ::std::default::Default::default()
    }

    // repeated .terra.oracle.v1beta1.Denom tobin_taxes = 1;


    pub fn get_tobin_taxes(&self) -> &[super::oracle::Denom] {
        &self.tobin_taxes
    }
    pub fn clear_tobin_taxes(&mut self) {
        self.tobin_taxes.clear();
    }

    // Param is passed by value, moved
    pub fn set_tobin_taxes(&mut self, v: ::protobuf::RepeatedField<super::oracle::Denom>) {
        self.tobin_taxes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tobin_taxes(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::Denom> {
        &mut self.tobin_taxes
    }

    // Take field
    pub fn take_tobin_taxes(&mut self) -> ::protobuf::RepeatedField<super::oracle::Denom> {
        ::std::mem::replace(&mut self.tobin_taxes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTobinTaxesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tobin_taxes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tobin_taxes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tobin_taxes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tobin_taxes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTobinTaxesResponse {
        QueryTobinTaxesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::Denom>>(
                "tobin_taxes",
                |m: &QueryTobinTaxesResponse| { &m.tobin_taxes },
                |m: &mut QueryTobinTaxesResponse| { &mut m.tobin_taxes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTobinTaxesResponse>(
                "QueryTobinTaxesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTobinTaxesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTobinTaxesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTobinTaxesResponse::new)
    }
}

impl ::protobuf::Clear for QueryTobinTaxesResponse {
    fn clear(&mut self) {
        self.tobin_taxes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTobinTaxesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTobinTaxesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryActivesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryActivesRequest {
    fn default() -> &'a QueryActivesRequest {
        <QueryActivesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryActivesRequest {
    pub fn new() -> QueryActivesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryActivesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryActivesRequest {
        QueryActivesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryActivesRequest>(
                "QueryActivesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryActivesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryActivesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryActivesRequest::new)
    }
}

impl ::protobuf::Clear for QueryActivesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryActivesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryActivesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryActivesResponse {
    // message fields
    pub actives: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryActivesResponse {
    fn default() -> &'a QueryActivesResponse {
        <QueryActivesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryActivesResponse {
    pub fn new() -> QueryActivesResponse {
        ::std::default::Default::default()
    }

    // repeated string actives = 1;


    pub fn get_actives(&self) -> &[::std::string::String] {
        &self.actives
    }
    pub fn clear_actives(&mut self) {
        self.actives.clear();
    }

    // Param is passed by value, moved
    pub fn set_actives(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.actives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actives(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.actives
    }

    // Take field
    pub fn take_actives(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.actives, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryActivesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actives)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actives {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actives {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryActivesResponse {
        QueryActivesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actives",
                |m: &QueryActivesResponse| { &m.actives },
                |m: &mut QueryActivesResponse| { &mut m.actives },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryActivesResponse>(
                "QueryActivesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryActivesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryActivesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryActivesResponse::new)
    }
}

impl ::protobuf::Clear for QueryActivesResponse {
    fn clear(&mut self) {
        self.actives.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryActivesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryActivesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryVoteTargetsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryVoteTargetsRequest {
    fn default() -> &'a QueryVoteTargetsRequest {
        <QueryVoteTargetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryVoteTargetsRequest {
    pub fn new() -> QueryVoteTargetsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryVoteTargetsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryVoteTargetsRequest {
        QueryVoteTargetsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryVoteTargetsRequest>(
                "QueryVoteTargetsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryVoteTargetsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryVoteTargetsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryVoteTargetsRequest::new)
    }
}

impl ::protobuf::Clear for QueryVoteTargetsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryVoteTargetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryVoteTargetsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryVoteTargetsResponse {
    // message fields
    pub vote_targets: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryVoteTargetsResponse {
    fn default() -> &'a QueryVoteTargetsResponse {
        <QueryVoteTargetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryVoteTargetsResponse {
    pub fn new() -> QueryVoteTargetsResponse {
        ::std::default::Default::default()
    }

    // repeated string vote_targets = 1;


    pub fn get_vote_targets(&self) -> &[::std::string::String] {
        &self.vote_targets
    }
    pub fn clear_vote_targets(&mut self) {
        self.vote_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_targets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.vote_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vote_targets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.vote_targets
    }

    // Take field
    pub fn take_vote_targets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.vote_targets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryVoteTargetsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.vote_targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vote_targets {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vote_targets {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryVoteTargetsResponse {
        QueryVoteTargetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vote_targets",
                |m: &QueryVoteTargetsResponse| { &m.vote_targets },
                |m: &mut QueryVoteTargetsResponse| { &mut m.vote_targets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryVoteTargetsResponse>(
                "QueryVoteTargetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryVoteTargetsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryVoteTargetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryVoteTargetsResponse::new)
    }
}

impl ::protobuf::Clear for QueryVoteTargetsResponse {
    fn clear(&mut self) {
        self.vote_targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryVoteTargetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryVoteTargetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryFeederDelegationRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeederDelegationRequest {
    fn default() -> &'a QueryFeederDelegationRequest {
        <QueryFeederDelegationRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeederDelegationRequest {
    pub fn new() -> QueryFeederDelegationRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryFeederDelegationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeederDelegationRequest {
        QueryFeederDelegationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryFeederDelegationRequest| { &m.validator_addr },
                |m: &mut QueryFeederDelegationRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryFeederDelegationRequest>(
                "QueryFeederDelegationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryFeederDelegationRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFeederDelegationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeederDelegationRequest::new)
    }
}

impl ::protobuf::Clear for QueryFeederDelegationRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryFeederDelegationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeederDelegationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryFeederDelegationResponse {
    // message fields
    pub feeder_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeederDelegationResponse {
    fn default() -> &'a QueryFeederDelegationResponse {
        <QueryFeederDelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeederDelegationResponse {
    pub fn new() -> QueryFeederDelegationResponse {
        ::std::default::Default::default()
    }

    // string feeder_addr = 1;


    pub fn get_feeder_addr(&self) -> &str {
        &self.feeder_addr
    }
    pub fn clear_feeder_addr(&mut self) {
        self.feeder_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_feeder_addr(&mut self, v: ::std::string::String) {
        self.feeder_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feeder_addr(&mut self) -> &mut ::std::string::String {
        &mut self.feeder_addr
    }

    // Take field
    pub fn take_feeder_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feeder_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryFeederDelegationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feeder_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.feeder_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feeder_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.feeder_addr.is_empty() {
            os.write_string(1, &self.feeder_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeederDelegationResponse {
        QueryFeederDelegationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "feeder_addr",
                |m: &QueryFeederDelegationResponse| { &m.feeder_addr },
                |m: &mut QueryFeederDelegationResponse| { &mut m.feeder_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryFeederDelegationResponse>(
                "QueryFeederDelegationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryFeederDelegationResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFeederDelegationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeederDelegationResponse::new)
    }
}

impl ::protobuf::Clear for QueryFeederDelegationResponse {
    fn clear(&mut self) {
        self.feeder_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryFeederDelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeederDelegationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryMissCounterRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMissCounterRequest {
    fn default() -> &'a QueryMissCounterRequest {
        <QueryMissCounterRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryMissCounterRequest {
    pub fn new() -> QueryMissCounterRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMissCounterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMissCounterRequest {
        QueryMissCounterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryMissCounterRequest| { &m.validator_addr },
                |m: &mut QueryMissCounterRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryMissCounterRequest>(
                "QueryMissCounterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryMissCounterRequest {
        static instance: ::protobuf::rt::LazyV2<QueryMissCounterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMissCounterRequest::new)
    }
}

impl ::protobuf::Clear for QueryMissCounterRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryMissCounterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMissCounterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryMissCounterResponse {
    // message fields
    pub miss_counter: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMissCounterResponse {
    fn default() -> &'a QueryMissCounterResponse {
        <QueryMissCounterResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryMissCounterResponse {
    pub fn new() -> QueryMissCounterResponse {
        ::std::default::Default::default()
    }

    // uint64 miss_counter = 1;


    pub fn get_miss_counter(&self) -> u64 {
        self.miss_counter
    }
    pub fn clear_miss_counter(&mut self) {
        self.miss_counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_miss_counter(&mut self, v: u64) {
        self.miss_counter = v;
    }
}

impl ::protobuf::Message for QueryMissCounterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.miss_counter = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.miss_counter != 0 {
            my_size += ::protobuf::rt::value_size(1, self.miss_counter, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.miss_counter != 0 {
            os.write_uint64(1, self.miss_counter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMissCounterResponse {
        QueryMissCounterResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "miss_counter",
                |m: &QueryMissCounterResponse| { &m.miss_counter },
                |m: &mut QueryMissCounterResponse| { &mut m.miss_counter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryMissCounterResponse>(
                "QueryMissCounterResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryMissCounterResponse {
        static instance: ::protobuf::rt::LazyV2<QueryMissCounterResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMissCounterResponse::new)
    }
}

impl ::protobuf::Clear for QueryMissCounterResponse {
    fn clear(&mut self) {
        self.miss_counter = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryMissCounterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMissCounterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregatePrevoteRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregatePrevoteRequest {
    fn default() -> &'a QueryAggregatePrevoteRequest {
        <QueryAggregatePrevoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregatePrevoteRequest {
    pub fn new() -> QueryAggregatePrevoteRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAggregatePrevoteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregatePrevoteRequest {
        QueryAggregatePrevoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryAggregatePrevoteRequest| { &m.validator_addr },
                |m: &mut QueryAggregatePrevoteRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregatePrevoteRequest>(
                "QueryAggregatePrevoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregatePrevoteRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregatePrevoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregatePrevoteRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregatePrevoteRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregatePrevoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregatePrevoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregatePrevoteResponse {
    // message fields
    pub aggregate_prevote: ::protobuf::SingularPtrField<super::oracle::AggregateExchangeRatePrevote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregatePrevoteResponse {
    fn default() -> &'a QueryAggregatePrevoteResponse {
        <QueryAggregatePrevoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregatePrevoteResponse {
    pub fn new() -> QueryAggregatePrevoteResponse {
        ::std::default::Default::default()
    }

    // .terra.oracle.v1beta1.AggregateExchangeRatePrevote aggregate_prevote = 1;


    pub fn get_aggregate_prevote(&self) -> &super::oracle::AggregateExchangeRatePrevote {
        self.aggregate_prevote.as_ref().unwrap_or_else(|| <super::oracle::AggregateExchangeRatePrevote as ::protobuf::Message>::default_instance())
    }
    pub fn clear_aggregate_prevote(&mut self) {
        self.aggregate_prevote.clear();
    }

    pub fn has_aggregate_prevote(&self) -> bool {
        self.aggregate_prevote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_prevote(&mut self, v: super::oracle::AggregateExchangeRatePrevote) {
        self.aggregate_prevote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_prevote(&mut self) -> &mut super::oracle::AggregateExchangeRatePrevote {
        if self.aggregate_prevote.is_none() {
            self.aggregate_prevote.set_default();
        }
        self.aggregate_prevote.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_prevote(&mut self) -> super::oracle::AggregateExchangeRatePrevote {
        self.aggregate_prevote.take().unwrap_or_else(|| super::oracle::AggregateExchangeRatePrevote::new())
    }
}

impl ::protobuf::Message for QueryAggregatePrevoteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_prevote {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregate_prevote)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.aggregate_prevote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.aggregate_prevote.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregatePrevoteResponse {
        QueryAggregatePrevoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::AggregateExchangeRatePrevote>>(
                "aggregate_prevote",
                |m: &QueryAggregatePrevoteResponse| { &m.aggregate_prevote },
                |m: &mut QueryAggregatePrevoteResponse| { &mut m.aggregate_prevote },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregatePrevoteResponse>(
                "QueryAggregatePrevoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregatePrevoteResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregatePrevoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregatePrevoteResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregatePrevoteResponse {
    fn clear(&mut self) {
        self.aggregate_prevote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregatePrevoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregatePrevoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregatePrevotesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregatePrevotesRequest {
    fn default() -> &'a QueryAggregatePrevotesRequest {
        <QueryAggregatePrevotesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregatePrevotesRequest {
    pub fn new() -> QueryAggregatePrevotesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryAggregatePrevotesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregatePrevotesRequest {
        QueryAggregatePrevotesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregatePrevotesRequest>(
                "QueryAggregatePrevotesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregatePrevotesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregatePrevotesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregatePrevotesRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregatePrevotesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregatePrevotesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregatePrevotesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregatePrevotesResponse {
    // message fields
    pub aggregate_prevotes: ::protobuf::RepeatedField<super::oracle::AggregateExchangeRatePrevote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregatePrevotesResponse {
    fn default() -> &'a QueryAggregatePrevotesResponse {
        <QueryAggregatePrevotesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregatePrevotesResponse {
    pub fn new() -> QueryAggregatePrevotesResponse {
        ::std::default::Default::default()
    }

    // repeated .terra.oracle.v1beta1.AggregateExchangeRatePrevote aggregate_prevotes = 1;


    pub fn get_aggregate_prevotes(&self) -> &[super::oracle::AggregateExchangeRatePrevote] {
        &self.aggregate_prevotes
    }
    pub fn clear_aggregate_prevotes(&mut self) {
        self.aggregate_prevotes.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_prevotes(&mut self, v: ::protobuf::RepeatedField<super::oracle::AggregateExchangeRatePrevote>) {
        self.aggregate_prevotes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregate_prevotes(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::AggregateExchangeRatePrevote> {
        &mut self.aggregate_prevotes
    }

    // Take field
    pub fn take_aggregate_prevotes(&mut self) -> ::protobuf::RepeatedField<super::oracle::AggregateExchangeRatePrevote> {
        ::std::mem::replace(&mut self.aggregate_prevotes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregatePrevotesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_prevotes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregate_prevotes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.aggregate_prevotes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aggregate_prevotes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregatePrevotesResponse {
        QueryAggregatePrevotesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::AggregateExchangeRatePrevote>>(
                "aggregate_prevotes",
                |m: &QueryAggregatePrevotesResponse| { &m.aggregate_prevotes },
                |m: &mut QueryAggregatePrevotesResponse| { &mut m.aggregate_prevotes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregatePrevotesResponse>(
                "QueryAggregatePrevotesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregatePrevotesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregatePrevotesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregatePrevotesResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregatePrevotesResponse {
    fn clear(&mut self) {
        self.aggregate_prevotes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregatePrevotesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregatePrevotesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregateVoteRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVoteRequest {
    fn default() -> &'a QueryAggregateVoteRequest {
        <QueryAggregateVoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVoteRequest {
    pub fn new() -> QueryAggregateVoteRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAggregateVoteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVoteRequest {
        QueryAggregateVoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryAggregateVoteRequest| { &m.validator_addr },
                |m: &mut QueryAggregateVoteRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregateVoteRequest>(
                "QueryAggregateVoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregateVoteRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVoteRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVoteRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregateVoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregateVoteResponse {
    // message fields
    pub aggregate_vote: ::protobuf::SingularPtrField<super::oracle::AggregateExchangeRateVote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVoteResponse {
    fn default() -> &'a QueryAggregateVoteResponse {
        <QueryAggregateVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVoteResponse {
    pub fn new() -> QueryAggregateVoteResponse {
        ::std::default::Default::default()
    }

    // .terra.oracle.v1beta1.AggregateExchangeRateVote aggregate_vote = 1;


    pub fn get_aggregate_vote(&self) -> &super::oracle::AggregateExchangeRateVote {
        self.aggregate_vote.as_ref().unwrap_or_else(|| <super::oracle::AggregateExchangeRateVote as ::protobuf::Message>::default_instance())
    }
    pub fn clear_aggregate_vote(&mut self) {
        self.aggregate_vote.clear();
    }

    pub fn has_aggregate_vote(&self) -> bool {
        self.aggregate_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_vote(&mut self, v: super::oracle::AggregateExchangeRateVote) {
        self.aggregate_vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_vote(&mut self) -> &mut super::oracle::AggregateExchangeRateVote {
        if self.aggregate_vote.is_none() {
            self.aggregate_vote.set_default();
        }
        self.aggregate_vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_vote(&mut self) -> super::oracle::AggregateExchangeRateVote {
        self.aggregate_vote.take().unwrap_or_else(|| super::oracle::AggregateExchangeRateVote::new())
    }
}

impl ::protobuf::Message for QueryAggregateVoteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_vote {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregate_vote)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.aggregate_vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.aggregate_vote.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVoteResponse {
        QueryAggregateVoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::AggregateExchangeRateVote>>(
                "aggregate_vote",
                |m: &QueryAggregateVoteResponse| { &m.aggregate_vote },
                |m: &mut QueryAggregateVoteResponse| { &mut m.aggregate_vote },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregateVoteResponse>(
                "QueryAggregateVoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregateVoteResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVoteResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVoteResponse {
    fn clear(&mut self) {
        self.aggregate_vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregateVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregateVotesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVotesRequest {
    fn default() -> &'a QueryAggregateVotesRequest {
        <QueryAggregateVotesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVotesRequest {
    pub fn new() -> QueryAggregateVotesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryAggregateVotesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVotesRequest {
        QueryAggregateVotesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregateVotesRequest>(
                "QueryAggregateVotesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregateVotesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVotesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVotesRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVotesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregateVotesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVotesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAggregateVotesResponse {
    // message fields
    pub aggregate_votes: ::protobuf::RepeatedField<super::oracle::AggregateExchangeRateVote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVotesResponse {
    fn default() -> &'a QueryAggregateVotesResponse {
        <QueryAggregateVotesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVotesResponse {
    pub fn new() -> QueryAggregateVotesResponse {
        ::std::default::Default::default()
    }

    // repeated .terra.oracle.v1beta1.AggregateExchangeRateVote aggregate_votes = 1;


    pub fn get_aggregate_votes(&self) -> &[super::oracle::AggregateExchangeRateVote] {
        &self.aggregate_votes
    }
    pub fn clear_aggregate_votes(&mut self) {
        self.aggregate_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_votes(&mut self, v: ::protobuf::RepeatedField<super::oracle::AggregateExchangeRateVote>) {
        self.aggregate_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregate_votes(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::AggregateExchangeRateVote> {
        &mut self.aggregate_votes
    }

    // Take field
    pub fn take_aggregate_votes(&mut self) -> ::protobuf::RepeatedField<super::oracle::AggregateExchangeRateVote> {
        ::std::mem::replace(&mut self.aggregate_votes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateVotesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregate_votes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.aggregate_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aggregate_votes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVotesResponse {
        QueryAggregateVotesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::AggregateExchangeRateVote>>(
                "aggregate_votes",
                |m: &QueryAggregateVotesResponse| { &m.aggregate_votes },
                |m: &mut QueryAggregateVotesResponse| { &mut m.aggregate_votes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAggregateVotesResponse>(
                "QueryAggregateVotesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAggregateVotesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVotesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVotesResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVotesResponse {
    fn clear(&mut self) {
        self.aggregate_votes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAggregateVotesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVotesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryParamsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsRequest {
    fn default() -> &'a QueryParamsRequest {
        <QueryParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsRequest {
    pub fn new() -> QueryParamsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsRequest {
        QueryParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParamsRequest>(
                "QueryParamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParamsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsRequest::new)
    }
}

impl ::protobuf::Clear for QueryParamsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryParamsResponse {
    // message fields
    pub params: ::protobuf::SingularPtrField<super::oracle::Params>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsResponse {
    fn default() -> &'a QueryParamsResponse {
        <QueryParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsResponse {
    pub fn new() -> QueryParamsResponse {
        ::std::default::Default::default()
    }

    // .terra.oracle.v1beta1.Params params = 1;


    pub fn get_params(&self) -> &super::oracle::Params {
        self.params.as_ref().unwrap_or_else(|| <super::oracle::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::oracle::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::oracle::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::oracle::Params {
        self.params.take().unwrap_or_else(|| super::oracle::Params::new())
    }
}

impl ::protobuf::Message for QueryParamsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsResponse {
        QueryParamsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oracle::Params>>(
                "params",
                |m: &QueryParamsResponse| { &m.params },
                |m: &mut QueryParamsResponse| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParamsResponse>(
                "QueryParamsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParamsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsResponse::new)
    }
}

impl ::protobuf::Clear for QueryParamsResponse {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20terra/oracle/v1beta1/query.proto\x12\x14terra.oracle.v1beta1\x1a\
    \x14gogoproto/gogo.proto\x1a\x1cgoogle/api/annotations.proto\x1a!terra/o\
    racle/v1beta1/oracle.proto\x1a\x1ecosmos/base/v1beta1/coin.proto\":\n\
    \x18QueryExchangeRateRequest\x12\x14\n\x05denom\x18\x01\x20\x01(\tR\x05d\
    enom:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"p\n\x19QueryExchangeRateResponse\
    \x12S\n\rexchange_rate\x18\x01\x20\x01(\tR\x0cexchangeRateB.\xda\xde\x1f\
    &github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\"\x1b\n\x19QueryEx\
    changeRatesRequest\"\x96\x01\n\x1aQueryExchangeRatesResponse\x12x\n\x0ee\
    xchange_rates\x18\x01\x20\x03(\x0b2\x1c.cosmos.base.v1beta1.DecCoinR\rex\
    changeRatesB3\xaa\xdf\x1f+github.com/cosmos/cosmos-sdk/types.DecCoins\
    \xc8\xde\x1f\0\"6\n\x14QueryTobinTaxRequest\x12\x14\n\x05denom\x18\x01\
    \x20\x01(\tR\x05denom:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"d\n\x15QueryTobi\
    nTaxResponse\x12K\n\ttobin_tax\x18\x01\x20\x01(\tR\x08tobinTaxB.\xda\xde\
    \x1f&github.com/cosmos/cosmos-sdk/types.Dec\xc8\xde\x1f\0\"\x18\n\x16Que\
    ryTobinTaxesRequest\"\x80\x01\n\x17QueryTobinTaxesResponse\x12e\n\x0btob\
    in_taxes\x18\x01\x20\x03(\x0b2\x1b.terra.oracle.v1beta1.DenomR\ntobinTax\
    esB'\xf2\xde\x1f\x12yaml:\"tobin_taxes\"\xaa\xdf\x1f\tDenomList\xc8\xde\
    \x1f\0\"\x15\n\x13QueryActivesRequest\"0\n\x14QueryActivesResponse\x12\
    \x18\n\x07actives\x18\x01\x20\x03(\tR\x07actives\"\x19\n\x17QueryVoteTar\
    getsRequest\"=\n\x18QueryVoteTargetsResponse\x12!\n\x0cvote_targets\x18\
    \x01\x20\x03(\tR\x0bvoteTargets\"O\n\x1cQueryFeederDelegationRequest\x12\
    %\n\x0evalidator_addr\x18\x01\x20\x01(\tR\rvalidatorAddr:\x08\x88\xa0\
    \x1f\0\xe8\xa0\x1f\0\"@\n\x1dQueryFeederDelegationResponse\x12\x1f\n\x0b\
    feeder_addr\x18\x01\x20\x01(\tR\nfeederAddr\"J\n\x17QueryMissCounterRequ\
    est\x12%\n\x0evalidator_addr\x18\x01\x20\x01(\tR\rvalidatorAddr:\x08\x88\
    \xa0\x1f\0\xe8\xa0\x1f\0\"=\n\x18QueryMissCounterResponse\x12!\n\x0cmiss\
    _counter\x18\x01\x20\x01(\x04R\x0bmissCounter\"O\n\x1cQueryAggregatePrev\
    oteRequest\x12%\n\x0evalidator_addr\x18\x01\x20\x01(\tR\rvalidatorAddr:\
    \x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x86\x01\n\x1dQueryAggregatePrevoteRes\
    ponse\x12e\n\x11aggregate_prevote\x18\x01\x20\x01(\x0b22.terra.oracle.v1\
    beta1.AggregateExchangeRatePrevoteR\x10aggregatePrevoteB\x04\xc8\xde\x1f\
    \0\"\x1f\n\x1dQueryAggregatePrevotesRequest\"\x89\x01\n\x1eQueryAggregat\
    ePrevotesResponse\x12g\n\x12aggregate_prevotes\x18\x01\x20\x03(\x0b22.te\
    rra.oracle.v1beta1.AggregateExchangeRatePrevoteR\x11aggregatePrevotesB\
    \x04\xc8\xde\x1f\0\"L\n\x19QueryAggregateVoteRequest\x12%\n\x0evalidator\
    _addr\x18\x01\x20\x01(\tR\rvalidatorAddr:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\
    \0\"z\n\x1aQueryAggregateVoteResponse\x12\\\n\x0eaggregate_vote\x18\x01\
    \x20\x01(\x0b2/.terra.oracle.v1beta1.AggregateExchangeRateVoteR\raggrega\
    teVoteB\x04\xc8\xde\x1f\0\"\x1c\n\x1aQueryAggregateVotesRequest\"}\n\x1b\
    QueryAggregateVotesResponse\x12^\n\x0faggregate_votes\x18\x01\x20\x03(\
    \x0b2/.terra.oracle.v1beta1.AggregateExchangeRateVoteR\x0eaggregateVotes\
    B\x04\xc8\xde\x1f\0\"\x14\n\x12QueryParamsRequest\"Q\n\x13QueryParamsRes\
    ponse\x12:\n\x06params\x18\x01\x20\x01(\x0b2\x1c.terra.oracle.v1beta1.Pa\
    ramsR\x06paramsB\x04\xc8\xde\x1f\02\xbd\x11\n\x05Query\x12\xab\x01\n\x0c\
    ExchangeRate\x12..terra.oracle.v1beta1.QueryExchangeRateRequest\x1a/.ter\
    ra.oracle.v1beta1.QueryExchangeRateResponse\":\x82\xd3\xe4\x93\x024\x122\
    /terra/oracle/v1beta1/denoms/{denom}/exchange_rate\x12\xa7\x01\n\rExchan\
    geRates\x12/.terra.oracle.v1beta1.QueryExchangeRatesRequest\x1a0.terra.o\
    racle.v1beta1.QueryExchangeRatesResponse\"3\x82\xd3\xe4\x93\x02-\x12+/te\
    rra/oracle/v1beta1/denoms/exchange_rates\x12\x9b\x01\n\x08TobinTax\x12*.\
    terra.oracle.v1beta1.QueryTobinTaxRequest\x1a+.terra.oracle.v1beta1.Quer\
    yTobinTaxResponse\"6\x82\xd3\xe4\x93\x020\x12./terra/oracle/v1beta1/deno\
    ms/{denom}/tobin_tax\x12\x9b\x01\n\nTobinTaxes\x12,.terra.oracle.v1beta1\
    .QueryTobinTaxesRequest\x1a-.terra.oracle.v1beta1.QueryTobinTaxesRespons\
    e\"0\x82\xd3\xe4\x93\x02*\x12(/terra/oracle/v1beta1/denoms/tobin_taxes\
    \x12\x8e\x01\n\x07Actives\x12).terra.oracle.v1beta1.QueryActivesRequest\
    \x1a*.terra.oracle.v1beta1.QueryActivesResponse\",\x82\xd3\xe4\x93\x02&\
    \x12$/terra/oracle/v1beta1/denoms/actives\x12\x9f\x01\n\x0bVoteTargets\
    \x12-.terra.oracle.v1beta1.QueryVoteTargetsRequest\x1a..terra.oracle.v1b\
    eta1.QueryVoteTargetsResponse\"1\x82\xd3\xe4\x93\x02+\x12)/terra/oracle/\
    v1beta1/denoms/vote_targets\x12\xbd\x01\n\x10FeederDelegation\x122.terra\
    .oracle.v1beta1.QueryFeederDelegationRequest\x1a3.terra.oracle.v1beta1.Q\
    ueryFeederDelegationResponse\"@\x82\xd3\xe4\x93\x02:\x128/terra/oracle/v\
    1beta1/validators/{validator_addr}/feeder\x12\xac\x01\n\x0bMissCounter\
    \x12-.terra.oracle.v1beta1.QueryMissCounterRequest\x1a..terra.oracle.v1b\
    eta1.QueryMissCounterResponse\">\x82\xd3\xe4\x93\x028\x126/terra/oracle/\
    v1beta1/validators/{validator_addr}/miss\x12\xc8\x01\n\x10AggregatePrevo\
    te\x122.terra.oracle.v1beta1.QueryAggregatePrevoteRequest\x1a3.terra.ora\
    cle.v1beta1.QueryAggregatePrevoteResponse\"K\x82\xd3\xe4\x93\x02E\x12C/t\
    erra/oracle/v1beta1/validators/{validator_addr}/aggregate_prevote\x12\
    \xbb\x01\n\x11AggregatePrevotes\x123.terra.oracle.v1beta1.QueryAggregate\
    PrevotesRequest\x1a4.terra.oracle.v1beta1.QueryAggregatePrevotesResponse\
    \";\x82\xd3\xe4\x93\x025\x123/terra/oracle/v1beta1/validators/aggregate_\
    prevotes\x12\xbc\x01\n\rAggregateVote\x12/.terra.oracle.v1beta1.QueryAgg\
    regateVoteRequest\x1a0.terra.oracle.v1beta1.QueryAggregateVoteResponse\"\
    H\x82\xd3\xe4\x93\x02B\x12@/terra/oracle/v1beta1/valdiators/{validator_a\
    ddr}/aggregate_vote\x12\xaf\x01\n\x0eAggregateVotes\x120.terra.oracle.v1\
    beta1.QueryAggregateVotesRequest\x1a1.terra.oracle.v1beta1.QueryAggregat\
    eVotesResponse\"8\x82\xd3\xe4\x93\x022\x120/terra/oracle/v1beta1/validat\
    ors/aggregate_votes\x12\x83\x01\n\x06Params\x12(.terra.oracle.v1beta1.Qu\
    eryParamsRequest\x1a).terra.oracle.v1beta1.QueryParamsResponse\"$\x82\
    \xd3\xe4\x93\x02\x1e\x12\x1c/terra/oracle/v1beta1/paramsB,Z*github.com/t\
    erra-money/core/x/oracle/typesb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
