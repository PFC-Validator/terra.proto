// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cosmos/staking/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorsRequest {
    // message fields
    pub status: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorsRequest {
    fn default() -> &'a QueryValidatorsRequest {
        <QueryValidatorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorsRequest {
    pub fn new() -> QueryValidatorsRequest {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryValidatorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorsRequest {
        QueryValidatorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &QueryValidatorsRequest| { &m.status },
                |m: &mut QueryValidatorsRequest| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryValidatorsRequest| { &m.pagination },
                |m: &mut QueryValidatorsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorsRequest>(
                "QueryValidatorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorsRequest::new)
    }
}

impl ::protobuf::Clear for QueryValidatorsRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorsResponse {
    // message fields
    pub validators: ::protobuf::RepeatedField<super::staking::Validator>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorsResponse {
    fn default() -> &'a QueryValidatorsResponse {
        <QueryValidatorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorsResponse {
    pub fn new() -> QueryValidatorsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.Validator validators = 1;


    pub fn get_validators(&self) -> &[super::staking::Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<super::staking::Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<super::staking::Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryValidatorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.validators {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorsResponse {
        QueryValidatorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Validator>>(
                "validators",
                |m: &QueryValidatorsResponse| { &m.validators },
                |m: &mut QueryValidatorsResponse| { &mut m.validators },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryValidatorsResponse| { &m.pagination },
                |m: &mut QueryValidatorsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorsResponse>(
                "QueryValidatorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorsResponse::new)
    }
}

impl ::protobuf::Clear for QueryValidatorsResponse {
    fn clear(&mut self) {
        self.validators.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorRequest {
    fn default() -> &'a QueryValidatorRequest {
        <QueryValidatorRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorRequest {
    pub fn new() -> QueryValidatorRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryValidatorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorRequest {
        QueryValidatorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryValidatorRequest| { &m.validator_addr },
                |m: &mut QueryValidatorRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorRequest>(
                "QueryValidatorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorRequest {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorRequest::new)
    }
}

impl ::protobuf::Clear for QueryValidatorRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorResponse {
    // message fields
    pub validator: ::protobuf::SingularPtrField<super::staking::Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorResponse {
    fn default() -> &'a QueryValidatorResponse {
        <QueryValidatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorResponse {
    pub fn new() -> QueryValidatorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Validator validator = 1;


    pub fn get_validator(&self) -> &super::staking::Validator {
        self.validator.as_ref().unwrap_or_else(|| <super::staking::Validator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validator(&mut self) {
        self.validator.clear();
    }

    pub fn has_validator(&self) -> bool {
        self.validator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validator(&mut self, v: super::staking::Validator) {
        self.validator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator(&mut self) -> &mut super::staking::Validator {
        if self.validator.is_none() {
            self.validator.set_default();
        }
        self.validator.as_mut().unwrap()
    }

    // Take field
    pub fn take_validator(&mut self) -> super::staking::Validator {
        self.validator.take().unwrap_or_else(|| super::staking::Validator::new())
    }
}

impl ::protobuf::Message for QueryValidatorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.validator.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorResponse {
        QueryValidatorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Validator>>(
                "validator",
                |m: &QueryValidatorResponse| { &m.validator },
                |m: &mut QueryValidatorResponse| { &mut m.validator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorResponse>(
                "QueryValidatorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorResponse {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorResponse::new)
    }
}

impl ::protobuf::Clear for QueryValidatorResponse {
    fn clear(&mut self) {
        self.validator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorDelegationsRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorDelegationsRequest {
    fn default() -> &'a QueryValidatorDelegationsRequest {
        <QueryValidatorDelegationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorDelegationsRequest {
    pub fn new() -> QueryValidatorDelegationsRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryValidatorDelegationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorDelegationsRequest {
        QueryValidatorDelegationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryValidatorDelegationsRequest| { &m.validator_addr },
                |m: &mut QueryValidatorDelegationsRequest| { &mut m.validator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryValidatorDelegationsRequest| { &m.pagination },
                |m: &mut QueryValidatorDelegationsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorDelegationsRequest>(
                "QueryValidatorDelegationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorDelegationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorDelegationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorDelegationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryValidatorDelegationsRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorDelegationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorDelegationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorDelegationsResponse {
    // message fields
    pub delegation_responses: ::protobuf::RepeatedField<super::staking::DelegationResponse>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorDelegationsResponse {
    fn default() -> &'a QueryValidatorDelegationsResponse {
        <QueryValidatorDelegationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorDelegationsResponse {
    pub fn new() -> QueryValidatorDelegationsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.DelegationResponse delegation_responses = 1;


    pub fn get_delegation_responses(&self) -> &[super::staking::DelegationResponse] {
        &self.delegation_responses
    }
    pub fn clear_delegation_responses(&mut self) {
        self.delegation_responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegation_responses(&mut self, v: ::protobuf::RepeatedField<super::staking::DelegationResponse>) {
        self.delegation_responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delegation_responses(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::DelegationResponse> {
        &mut self.delegation_responses
    }

    // Take field
    pub fn take_delegation_responses(&mut self) -> ::protobuf::RepeatedField<super::staking::DelegationResponse> {
        ::std::mem::replace(&mut self.delegation_responses, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryValidatorDelegationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.delegation_responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.delegation_responses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.delegation_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.delegation_responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorDelegationsResponse {
        QueryValidatorDelegationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::DelegationResponse>>(
                "delegation_responses",
                |m: &QueryValidatorDelegationsResponse| { &m.delegation_responses },
                |m: &mut QueryValidatorDelegationsResponse| { &mut m.delegation_responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryValidatorDelegationsResponse| { &m.pagination },
                |m: &mut QueryValidatorDelegationsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorDelegationsResponse>(
                "QueryValidatorDelegationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorDelegationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorDelegationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorDelegationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryValidatorDelegationsResponse {
    fn clear(&mut self) {
        self.delegation_responses.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorDelegationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorDelegationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorUnbondingDelegationsRequest {
    // message fields
    pub validator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorUnbondingDelegationsRequest {
    fn default() -> &'a QueryValidatorUnbondingDelegationsRequest {
        <QueryValidatorUnbondingDelegationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorUnbondingDelegationsRequest {
    pub fn new() -> QueryValidatorUnbondingDelegationsRequest {
        ::std::default::Default::default()
    }

    // string validator_addr = 1;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryValidatorUnbondingDelegationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.validator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.validator_addr.is_empty() {
            os.write_string(1, &self.validator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorUnbondingDelegationsRequest {
        QueryValidatorUnbondingDelegationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryValidatorUnbondingDelegationsRequest| { &m.validator_addr },
                |m: &mut QueryValidatorUnbondingDelegationsRequest| { &mut m.validator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryValidatorUnbondingDelegationsRequest| { &m.pagination },
                |m: &mut QueryValidatorUnbondingDelegationsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorUnbondingDelegationsRequest>(
                "QueryValidatorUnbondingDelegationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorUnbondingDelegationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorUnbondingDelegationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorUnbondingDelegationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryValidatorUnbondingDelegationsRequest {
    fn clear(&mut self) {
        self.validator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorUnbondingDelegationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorUnbondingDelegationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryValidatorUnbondingDelegationsResponse {
    // message fields
    pub unbonding_responses: ::protobuf::RepeatedField<super::staking::UnbondingDelegation>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryValidatorUnbondingDelegationsResponse {
    fn default() -> &'a QueryValidatorUnbondingDelegationsResponse {
        <QueryValidatorUnbondingDelegationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryValidatorUnbondingDelegationsResponse {
    pub fn new() -> QueryValidatorUnbondingDelegationsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.UnbondingDelegation unbonding_responses = 1;


    pub fn get_unbonding_responses(&self) -> &[super::staking::UnbondingDelegation] {
        &self.unbonding_responses
    }
    pub fn clear_unbonding_responses(&mut self) {
        self.unbonding_responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_unbonding_responses(&mut self, v: ::protobuf::RepeatedField<super::staking::UnbondingDelegation>) {
        self.unbonding_responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unbonding_responses(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::UnbondingDelegation> {
        &mut self.unbonding_responses
    }

    // Take field
    pub fn take_unbonding_responses(&mut self) -> ::protobuf::RepeatedField<super::staking::UnbondingDelegation> {
        ::std::mem::replace(&mut self.unbonding_responses, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryValidatorUnbondingDelegationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.unbonding_responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unbonding_responses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unbonding_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unbonding_responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryValidatorUnbondingDelegationsResponse {
        QueryValidatorUnbondingDelegationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::UnbondingDelegation>>(
                "unbonding_responses",
                |m: &QueryValidatorUnbondingDelegationsResponse| { &m.unbonding_responses },
                |m: &mut QueryValidatorUnbondingDelegationsResponse| { &mut m.unbonding_responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryValidatorUnbondingDelegationsResponse| { &m.pagination },
                |m: &mut QueryValidatorUnbondingDelegationsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryValidatorUnbondingDelegationsResponse>(
                "QueryValidatorUnbondingDelegationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryValidatorUnbondingDelegationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryValidatorUnbondingDelegationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryValidatorUnbondingDelegationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryValidatorUnbondingDelegationsResponse {
    fn clear(&mut self) {
        self.unbonding_responses.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryValidatorUnbondingDelegationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryValidatorUnbondingDelegationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegationRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegationRequest {
    fn default() -> &'a QueryDelegationRequest {
        <QueryDelegationRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationRequest {
    pub fn new() -> QueryDelegationRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // string validator_addr = 2;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDelegationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if !self.validator_addr.is_empty() {
            os.write_string(2, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegationRequest {
        QueryDelegationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryDelegationRequest| { &m.delegator_addr },
                |m: &mut QueryDelegationRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryDelegationRequest| { &m.validator_addr },
                |m: &mut QueryDelegationRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegationRequest>(
                "QueryDelegationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegationRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDelegationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegationRequest::new)
    }
}

impl ::protobuf::Clear for QueryDelegationRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegationResponse {
    // message fields
    pub delegation_response: ::protobuf::SingularPtrField<super::staking::DelegationResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegationResponse {
    fn default() -> &'a QueryDelegationResponse {
        <QueryDelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegationResponse {
    pub fn new() -> QueryDelegationResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.DelegationResponse delegation_response = 1;


    pub fn get_delegation_response(&self) -> &super::staking::DelegationResponse {
        self.delegation_response.as_ref().unwrap_or_else(|| <super::staking::DelegationResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delegation_response(&mut self) {
        self.delegation_response.clear();
    }

    pub fn has_delegation_response(&self) -> bool {
        self.delegation_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegation_response(&mut self, v: super::staking::DelegationResponse) {
        self.delegation_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegation_response(&mut self) -> &mut super::staking::DelegationResponse {
        if self.delegation_response.is_none() {
            self.delegation_response.set_default();
        }
        self.delegation_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegation_response(&mut self) -> super::staking::DelegationResponse {
        self.delegation_response.take().unwrap_or_else(|| super::staking::DelegationResponse::new())
    }
}

impl ::protobuf::Message for QueryDelegationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.delegation_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegation_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delegation_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delegation_response.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegationResponse {
        QueryDelegationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::DelegationResponse>>(
                "delegation_response",
                |m: &QueryDelegationResponse| { &m.delegation_response },
                |m: &mut QueryDelegationResponse| { &mut m.delegation_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegationResponse>(
                "QueryDelegationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegationResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDelegationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegationResponse::new)
    }
}

impl ::protobuf::Clear for QueryDelegationResponse {
    fn clear(&mut self) {
        self.delegation_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryUnbondingDelegationRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryUnbondingDelegationRequest {
    fn default() -> &'a QueryUnbondingDelegationRequest {
        <QueryUnbondingDelegationRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnbondingDelegationRequest {
    pub fn new() -> QueryUnbondingDelegationRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // string validator_addr = 2;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryUnbondingDelegationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if !self.validator_addr.is_empty() {
            os.write_string(2, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryUnbondingDelegationRequest {
        QueryUnbondingDelegationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryUnbondingDelegationRequest| { &m.delegator_addr },
                |m: &mut QueryUnbondingDelegationRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryUnbondingDelegationRequest| { &m.validator_addr },
                |m: &mut QueryUnbondingDelegationRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryUnbondingDelegationRequest>(
                "QueryUnbondingDelegationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryUnbondingDelegationRequest {
        static instance: ::protobuf::rt::LazyV2<QueryUnbondingDelegationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryUnbondingDelegationRequest::new)
    }
}

impl ::protobuf::Clear for QueryUnbondingDelegationRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryUnbondingDelegationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnbondingDelegationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryUnbondingDelegationResponse {
    // message fields
    pub unbond: ::protobuf::SingularPtrField<super::staking::UnbondingDelegation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryUnbondingDelegationResponse {
    fn default() -> &'a QueryUnbondingDelegationResponse {
        <QueryUnbondingDelegationResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryUnbondingDelegationResponse {
    pub fn new() -> QueryUnbondingDelegationResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.UnbondingDelegation unbond = 1;


    pub fn get_unbond(&self) -> &super::staking::UnbondingDelegation {
        self.unbond.as_ref().unwrap_or_else(|| <super::staking::UnbondingDelegation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unbond(&mut self) {
        self.unbond.clear();
    }

    pub fn has_unbond(&self) -> bool {
        self.unbond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unbond(&mut self, v: super::staking::UnbondingDelegation) {
        self.unbond = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unbond(&mut self) -> &mut super::staking::UnbondingDelegation {
        if self.unbond.is_none() {
            self.unbond.set_default();
        }
        self.unbond.as_mut().unwrap()
    }

    // Take field
    pub fn take_unbond(&mut self) -> super::staking::UnbondingDelegation {
        self.unbond.take().unwrap_or_else(|| super::staking::UnbondingDelegation::new())
    }
}

impl ::protobuf::Message for QueryUnbondingDelegationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.unbond {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unbond)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unbond.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unbond.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryUnbondingDelegationResponse {
        QueryUnbondingDelegationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::UnbondingDelegation>>(
                "unbond",
                |m: &QueryUnbondingDelegationResponse| { &m.unbond },
                |m: &mut QueryUnbondingDelegationResponse| { &mut m.unbond },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryUnbondingDelegationResponse>(
                "QueryUnbondingDelegationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryUnbondingDelegationResponse {
        static instance: ::protobuf::rt::LazyV2<QueryUnbondingDelegationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryUnbondingDelegationResponse::new)
    }
}

impl ::protobuf::Clear for QueryUnbondingDelegationResponse {
    fn clear(&mut self) {
        self.unbond.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryUnbondingDelegationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUnbondingDelegationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorDelegationsRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorDelegationsRequest {
    fn default() -> &'a QueryDelegatorDelegationsRequest {
        <QueryDelegatorDelegationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorDelegationsRequest {
    pub fn new() -> QueryDelegatorDelegationsRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryDelegatorDelegationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorDelegationsRequest {
        QueryDelegatorDelegationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryDelegatorDelegationsRequest| { &m.delegator_addr },
                |m: &mut QueryDelegatorDelegationsRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryDelegatorDelegationsRequest| { &m.pagination },
                |m: &mut QueryDelegatorDelegationsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorDelegationsRequest>(
                "QueryDelegatorDelegationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorDelegationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorDelegationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorDelegationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorDelegationsRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorDelegationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorDelegationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorDelegationsResponse {
    // message fields
    pub delegation_responses: ::protobuf::RepeatedField<super::staking::DelegationResponse>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorDelegationsResponse {
    fn default() -> &'a QueryDelegatorDelegationsResponse {
        <QueryDelegatorDelegationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorDelegationsResponse {
    pub fn new() -> QueryDelegatorDelegationsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.DelegationResponse delegation_responses = 1;


    pub fn get_delegation_responses(&self) -> &[super::staking::DelegationResponse] {
        &self.delegation_responses
    }
    pub fn clear_delegation_responses(&mut self) {
        self.delegation_responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegation_responses(&mut self, v: ::protobuf::RepeatedField<super::staking::DelegationResponse>) {
        self.delegation_responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delegation_responses(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::DelegationResponse> {
        &mut self.delegation_responses
    }

    // Take field
    pub fn take_delegation_responses(&mut self) -> ::protobuf::RepeatedField<super::staking::DelegationResponse> {
        ::std::mem::replace(&mut self.delegation_responses, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryDelegatorDelegationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.delegation_responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.delegation_responses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.delegation_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.delegation_responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorDelegationsResponse {
        QueryDelegatorDelegationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::DelegationResponse>>(
                "delegation_responses",
                |m: &QueryDelegatorDelegationsResponse| { &m.delegation_responses },
                |m: &mut QueryDelegatorDelegationsResponse| { &mut m.delegation_responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryDelegatorDelegationsResponse| { &m.pagination },
                |m: &mut QueryDelegatorDelegationsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorDelegationsResponse>(
                "QueryDelegatorDelegationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorDelegationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorDelegationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorDelegationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorDelegationsResponse {
    fn clear(&mut self) {
        self.delegation_responses.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorDelegationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorDelegationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorUnbondingDelegationsRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorUnbondingDelegationsRequest {
    fn default() -> &'a QueryDelegatorUnbondingDelegationsRequest {
        <QueryDelegatorUnbondingDelegationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorUnbondingDelegationsRequest {
    pub fn new() -> QueryDelegatorUnbondingDelegationsRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryDelegatorUnbondingDelegationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorUnbondingDelegationsRequest {
        QueryDelegatorUnbondingDelegationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryDelegatorUnbondingDelegationsRequest| { &m.delegator_addr },
                |m: &mut QueryDelegatorUnbondingDelegationsRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryDelegatorUnbondingDelegationsRequest| { &m.pagination },
                |m: &mut QueryDelegatorUnbondingDelegationsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorUnbondingDelegationsRequest>(
                "QueryDelegatorUnbondingDelegationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorUnbondingDelegationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorUnbondingDelegationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorUnbondingDelegationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorUnbondingDelegationsRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorUnbondingDelegationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorUnbondingDelegationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorUnbondingDelegationsResponse {
    // message fields
    pub unbonding_responses: ::protobuf::RepeatedField<super::staking::UnbondingDelegation>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorUnbondingDelegationsResponse {
    fn default() -> &'a QueryDelegatorUnbondingDelegationsResponse {
        <QueryDelegatorUnbondingDelegationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorUnbondingDelegationsResponse {
    pub fn new() -> QueryDelegatorUnbondingDelegationsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.UnbondingDelegation unbonding_responses = 1;


    pub fn get_unbonding_responses(&self) -> &[super::staking::UnbondingDelegation] {
        &self.unbonding_responses
    }
    pub fn clear_unbonding_responses(&mut self) {
        self.unbonding_responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_unbonding_responses(&mut self, v: ::protobuf::RepeatedField<super::staking::UnbondingDelegation>) {
        self.unbonding_responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unbonding_responses(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::UnbondingDelegation> {
        &mut self.unbonding_responses
    }

    // Take field
    pub fn take_unbonding_responses(&mut self) -> ::protobuf::RepeatedField<super::staking::UnbondingDelegation> {
        ::std::mem::replace(&mut self.unbonding_responses, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryDelegatorUnbondingDelegationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.unbonding_responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unbonding_responses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unbonding_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unbonding_responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorUnbondingDelegationsResponse {
        QueryDelegatorUnbondingDelegationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::UnbondingDelegation>>(
                "unbonding_responses",
                |m: &QueryDelegatorUnbondingDelegationsResponse| { &m.unbonding_responses },
                |m: &mut QueryDelegatorUnbondingDelegationsResponse| { &mut m.unbonding_responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryDelegatorUnbondingDelegationsResponse| { &m.pagination },
                |m: &mut QueryDelegatorUnbondingDelegationsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorUnbondingDelegationsResponse>(
                "QueryDelegatorUnbondingDelegationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorUnbondingDelegationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorUnbondingDelegationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorUnbondingDelegationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorUnbondingDelegationsResponse {
    fn clear(&mut self) {
        self.unbonding_responses.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorUnbondingDelegationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorUnbondingDelegationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRedelegationsRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub src_validator_addr: ::std::string::String,
    pub dst_validator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRedelegationsRequest {
    fn default() -> &'a QueryRedelegationsRequest {
        <QueryRedelegationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRedelegationsRequest {
    pub fn new() -> QueryRedelegationsRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // string src_validator_addr = 2;


    pub fn get_src_validator_addr(&self) -> &str {
        &self.src_validator_addr
    }
    pub fn clear_src_validator_addr(&mut self) {
        self.src_validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_validator_addr(&mut self, v: ::std::string::String) {
        self.src_validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.src_validator_addr
    }

    // Take field
    pub fn take_src_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_validator_addr, ::std::string::String::new())
    }

    // string dst_validator_addr = 3;


    pub fn get_dst_validator_addr(&self) -> &str {
        &self.dst_validator_addr
    }
    pub fn clear_dst_validator_addr(&mut self) {
        self.dst_validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_validator_addr(&mut self, v: ::std::string::String) {
        self.dst_validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.dst_validator_addr
    }

    // Take field
    pub fn take_dst_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_validator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 4;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryRedelegationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_validator_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_validator_addr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if !self.src_validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.src_validator_addr);
        }
        if !self.dst_validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dst_validator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if !self.src_validator_addr.is_empty() {
            os.write_string(2, &self.src_validator_addr)?;
        }
        if !self.dst_validator_addr.is_empty() {
            os.write_string(3, &self.dst_validator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRedelegationsRequest {
        QueryRedelegationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryRedelegationsRequest| { &m.delegator_addr },
                |m: &mut QueryRedelegationsRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src_validator_addr",
                |m: &QueryRedelegationsRequest| { &m.src_validator_addr },
                |m: &mut QueryRedelegationsRequest| { &mut m.src_validator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dst_validator_addr",
                |m: &QueryRedelegationsRequest| { &m.dst_validator_addr },
                |m: &mut QueryRedelegationsRequest| { &mut m.dst_validator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryRedelegationsRequest| { &m.pagination },
                |m: &mut QueryRedelegationsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRedelegationsRequest>(
                "QueryRedelegationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRedelegationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryRedelegationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRedelegationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryRedelegationsRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.src_validator_addr.clear();
        self.dst_validator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRedelegationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRedelegationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRedelegationsResponse {
    // message fields
    pub redelegation_responses: ::protobuf::RepeatedField<super::staking::RedelegationResponse>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRedelegationsResponse {
    fn default() -> &'a QueryRedelegationsResponse {
        <QueryRedelegationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRedelegationsResponse {
    pub fn new() -> QueryRedelegationsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.RedelegationResponse redelegation_responses = 1;


    pub fn get_redelegation_responses(&self) -> &[super::staking::RedelegationResponse] {
        &self.redelegation_responses
    }
    pub fn clear_redelegation_responses(&mut self) {
        self.redelegation_responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_redelegation_responses(&mut self, v: ::protobuf::RepeatedField<super::staking::RedelegationResponse>) {
        self.redelegation_responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redelegation_responses(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::RedelegationResponse> {
        &mut self.redelegation_responses
    }

    // Take field
    pub fn take_redelegation_responses(&mut self) -> ::protobuf::RepeatedField<super::staking::RedelegationResponse> {
        ::std::mem::replace(&mut self.redelegation_responses, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryRedelegationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.redelegation_responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.redelegation_responses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.redelegation_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.redelegation_responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRedelegationsResponse {
        QueryRedelegationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::RedelegationResponse>>(
                "redelegation_responses",
                |m: &QueryRedelegationsResponse| { &m.redelegation_responses },
                |m: &mut QueryRedelegationsResponse| { &mut m.redelegation_responses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryRedelegationsResponse| { &m.pagination },
                |m: &mut QueryRedelegationsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRedelegationsResponse>(
                "QueryRedelegationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRedelegationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryRedelegationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRedelegationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryRedelegationsResponse {
    fn clear(&mut self) {
        self.redelegation_responses.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRedelegationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRedelegationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorValidatorsRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorsRequest {
    fn default() -> &'a QueryDelegatorValidatorsRequest {
        <QueryDelegatorValidatorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorsRequest {
    pub fn new() -> QueryDelegatorValidatorsRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorValidatorsRequest {
        QueryDelegatorValidatorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryDelegatorValidatorsRequest| { &m.delegator_addr },
                |m: &mut QueryDelegatorValidatorsRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &QueryDelegatorValidatorsRequest| { &m.pagination },
                |m: &mut QueryDelegatorValidatorsRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorValidatorsRequest>(
                "QueryDelegatorValidatorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorValidatorsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorValidatorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorValidatorsRequest::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorValidatorsRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorValidatorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorValidatorsResponse {
    // message fields
    pub validators: ::protobuf::RepeatedField<super::staking::Validator>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorsResponse {
    fn default() -> &'a QueryDelegatorValidatorsResponse {
        <QueryDelegatorValidatorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorsResponse {
    pub fn new() -> QueryDelegatorValidatorsResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.staking.v1beta1.Validator validators = 1;


    pub fn get_validators(&self) -> &[super::staking::Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<super::staking::Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<super::staking::Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<super::staking::Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.validators {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorValidatorsResponse {
        QueryDelegatorValidatorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Validator>>(
                "validators",
                |m: &QueryDelegatorValidatorsResponse| { &m.validators },
                |m: &mut QueryDelegatorValidatorsResponse| { &mut m.validators },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &QueryDelegatorValidatorsResponse| { &m.pagination },
                |m: &mut QueryDelegatorValidatorsResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorValidatorsResponse>(
                "QueryDelegatorValidatorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorValidatorsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorValidatorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorValidatorsResponse::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorValidatorsResponse {
    fn clear(&mut self) {
        self.validators.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorValidatorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorValidatorRequest {
    // message fields
    pub delegator_addr: ::std::string::String,
    pub validator_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorRequest {
    fn default() -> &'a QueryDelegatorValidatorRequest {
        <QueryDelegatorValidatorRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorRequest {
    pub fn new() -> QueryDelegatorValidatorRequest {
        ::std::default::Default::default()
    }

    // string delegator_addr = 1;


    pub fn get_delegator_addr(&self) -> &str {
        &self.delegator_addr
    }
    pub fn clear_delegator_addr(&mut self) {
        self.delegator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_addr(&mut self, v: ::std::string::String) {
        self.delegator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_addr
    }

    // Take field
    pub fn take_delegator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_addr, ::std::string::String::new())
    }

    // string validator_addr = 2;


    pub fn get_validator_addr(&self) -> &str {
        &self.validator_addr
    }
    pub fn clear_validator_addr(&mut self) {
        self.validator_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator_addr(&mut self, v: ::std::string::String) {
        self.validator_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator_addr(&mut self) -> &mut ::std::string::String {
        &mut self.validator_addr
    }

    // Take field
    pub fn take_validator_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delegator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.delegator_addr);
        }
        if !self.validator_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.validator_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delegator_addr.is_empty() {
            os.write_string(1, &self.delegator_addr)?;
        }
        if !self.validator_addr.is_empty() {
            os.write_string(2, &self.validator_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorValidatorRequest {
        QueryDelegatorValidatorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delegator_addr",
                |m: &QueryDelegatorValidatorRequest| { &m.delegator_addr },
                |m: &mut QueryDelegatorValidatorRequest| { &mut m.delegator_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "validator_addr",
                |m: &QueryDelegatorValidatorRequest| { &m.validator_addr },
                |m: &mut QueryDelegatorValidatorRequest| { &mut m.validator_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorValidatorRequest>(
                "QueryDelegatorValidatorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorValidatorRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorValidatorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorValidatorRequest::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorValidatorRequest {
    fn clear(&mut self) {
        self.delegator_addr.clear();
        self.validator_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorValidatorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryDelegatorValidatorResponse {
    // message fields
    pub validator: ::protobuf::SingularPtrField<super::staking::Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDelegatorValidatorResponse {
    fn default() -> &'a QueryDelegatorValidatorResponse {
        <QueryDelegatorValidatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDelegatorValidatorResponse {
    pub fn new() -> QueryDelegatorValidatorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Validator validator = 1;


    pub fn get_validator(&self) -> &super::staking::Validator {
        self.validator.as_ref().unwrap_or_else(|| <super::staking::Validator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validator(&mut self) {
        self.validator.clear();
    }

    pub fn has_validator(&self) -> bool {
        self.validator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validator(&mut self, v: super::staking::Validator) {
        self.validator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator(&mut self) -> &mut super::staking::Validator {
        if self.validator.is_none() {
            self.validator.set_default();
        }
        self.validator.as_mut().unwrap()
    }

    // Take field
    pub fn take_validator(&mut self) -> super::staking::Validator {
        self.validator.take().unwrap_or_else(|| super::staking::Validator::new())
    }
}

impl ::protobuf::Message for QueryDelegatorValidatorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.validator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.validator.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDelegatorValidatorResponse {
        QueryDelegatorValidatorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Validator>>(
                "validator",
                |m: &QueryDelegatorValidatorResponse| { &m.validator },
                |m: &mut QueryDelegatorValidatorResponse| { &mut m.validator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryDelegatorValidatorResponse>(
                "QueryDelegatorValidatorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryDelegatorValidatorResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDelegatorValidatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDelegatorValidatorResponse::new)
    }
}

impl ::protobuf::Clear for QueryDelegatorValidatorResponse {
    fn clear(&mut self) {
        self.validator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryDelegatorValidatorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDelegatorValidatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryHistoricalInfoRequest {
    // message fields
    pub height: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalInfoRequest {
    fn default() -> &'a QueryHistoricalInfoRequest {
        <QueryHistoricalInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalInfoRequest {
    pub fn new() -> QueryHistoricalInfoRequest {
        ::std::default::Default::default()
    }

    // int64 height = 1;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }
}

impl ::protobuf::Message for QueryHistoricalInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalInfoRequest {
        QueryHistoricalInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "height",
                |m: &QueryHistoricalInfoRequest| { &m.height },
                |m: &mut QueryHistoricalInfoRequest| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryHistoricalInfoRequest>(
                "QueryHistoricalInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryHistoricalInfoRequest {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalInfoRequest::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalInfoRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryHistoricalInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryHistoricalInfoResponse {
    // message fields
    pub hist: ::protobuf::SingularPtrField<super::staking::HistoricalInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalInfoResponse {
    fn default() -> &'a QueryHistoricalInfoResponse {
        <QueryHistoricalInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalInfoResponse {
    pub fn new() -> QueryHistoricalInfoResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.HistoricalInfo hist = 1;


    pub fn get_hist(&self) -> &super::staking::HistoricalInfo {
        self.hist.as_ref().unwrap_or_else(|| <super::staking::HistoricalInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hist(&mut self) {
        self.hist.clear();
    }

    pub fn has_hist(&self) -> bool {
        self.hist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hist(&mut self, v: super::staking::HistoricalInfo) {
        self.hist = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hist(&mut self) -> &mut super::staking::HistoricalInfo {
        if self.hist.is_none() {
            self.hist.set_default();
        }
        self.hist.as_mut().unwrap()
    }

    // Take field
    pub fn take_hist(&mut self) -> super::staking::HistoricalInfo {
        self.hist.take().unwrap_or_else(|| super::staking::HistoricalInfo::new())
    }
}

impl ::protobuf::Message for QueryHistoricalInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.hist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hist.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalInfoResponse {
        QueryHistoricalInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::HistoricalInfo>>(
                "hist",
                |m: &QueryHistoricalInfoResponse| { &m.hist },
                |m: &mut QueryHistoricalInfoResponse| { &mut m.hist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryHistoricalInfoResponse>(
                "QueryHistoricalInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryHistoricalInfoResponse {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalInfoResponse::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalInfoResponse {
    fn clear(&mut self) {
        self.hist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryHistoricalInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryPoolRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPoolRequest {
    fn default() -> &'a QueryPoolRequest {
        <QueryPoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolRequest {
    pub fn new() -> QueryPoolRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryPoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPoolRequest {
        QueryPoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryPoolRequest>(
                "QueryPoolRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryPoolRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPoolRequest::new)
    }
}

impl ::protobuf::Clear for QueryPoolRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryPoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryPoolResponse {
    // message fields
    pub pool: ::protobuf::SingularPtrField<super::staking::Pool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPoolResponse {
    fn default() -> &'a QueryPoolResponse {
        <QueryPoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolResponse {
    pub fn new() -> QueryPoolResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Pool pool = 1;


    pub fn get_pool(&self) -> &super::staking::Pool {
        self.pool.as_ref().unwrap_or_else(|| <super::staking::Pool as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: super::staking::Pool) {
        self.pool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut super::staking::Pool {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> super::staking::Pool {
        self.pool.take().unwrap_or_else(|| super::staking::Pool::new())
    }
}

impl ::protobuf::Message for QueryPoolResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pool {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pool)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pool.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPoolResponse {
        QueryPoolResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Pool>>(
                "pool",
                |m: &QueryPoolResponse| { &m.pool },
                |m: &mut QueryPoolResponse| { &mut m.pool },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryPoolResponse>(
                "QueryPoolResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryPoolResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPoolResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPoolResponse::new)
    }
}

impl ::protobuf::Clear for QueryPoolResponse {
    fn clear(&mut self) {
        self.pool.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryPoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryParamsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsRequest {
    fn default() -> &'a QueryParamsRequest {
        <QueryParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsRequest {
    pub fn new() -> QueryParamsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsRequest {
        QueryParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParamsRequest>(
                "QueryParamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParamsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsRequest::new)
    }
}

impl ::protobuf::Clear for QueryParamsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryParamsResponse {
    // message fields
    pub params: ::protobuf::SingularPtrField<super::staking::Params>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsResponse {
    fn default() -> &'a QueryParamsResponse {
        <QueryParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsResponse {
    pub fn new() -> QueryParamsResponse {
        ::std::default::Default::default()
    }

    // .cosmos.staking.v1beta1.Params params = 1;


    pub fn get_params(&self) -> &super::staking::Params {
        self.params.as_ref().unwrap_or_else(|| <super::staking::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::staking::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::staking::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::staking::Params {
        self.params.take().unwrap_or_else(|| super::staking::Params::new())
    }
}

impl ::protobuf::Message for QueryParamsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsResponse {
        QueryParamsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::staking::Params>>(
                "params",
                |m: &QueryParamsResponse| { &m.params },
                |m: &mut QueryParamsResponse| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParamsResponse>(
                "QueryParamsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParamsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsResponse::new)
    }
}

impl ::protobuf::Clear for QueryParamsResponse {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"cosmos/staking/v1beta1/query.proto\x12\x16cosmos.staking.v1beta1\x1a\
    *cosmos/base/query/v1beta1/pagination.proto\x1a\x14gogoproto/gogo.proto\
    \x1a\x1cgoogle/api/annotations.proto\x1a$cosmos/staking/v1beta1/staking.\
    proto\"x\n\x16QueryValidatorsRequest\x12\x16\n\x06status\x18\x01\x20\x01\
    (\tR\x06status\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmos.base.que\
    ry.v1beta1.PageRequestR\npagination\"\xab\x01\n\x17QueryValidatorsRespon\
    se\x12G\n\nvalidators\x18\x01\x20\x03(\x0b2!.cosmos.staking.v1beta1.Vali\
    datorR\nvalidatorsB\x04\xc8\xde\x1f\0\x12G\n\npagination\x18\x02\x20\x01\
    (\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\">\n\x15Quer\
    yValidatorRequest\x12%\n\x0evalidator_addr\x18\x01\x20\x01(\tR\rvalidato\
    rAddr\"_\n\x16QueryValidatorResponse\x12E\n\tvalidator\x18\x01\x20\x01(\
    \x0b2!.cosmos.staking.v1beta1.ValidatorR\tvalidatorB\x04\xc8\xde\x1f\0\"\
    \x91\x01\n\x20QueryValidatorDelegationsRequest\x12%\n\x0evalidator_addr\
    \x18\x01\x20\x01(\tR\rvalidatorAddr\x12F\n\npagination\x18\x02\x20\x01(\
    \x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination\"\xe8\x01\n!Qu\
    eryValidatorDelegationsResponse\x12z\n\x14delegation_responses\x18\x01\
    \x20\x03(\x0b2*.cosmos.staking.v1beta1.DelegationResponseR\x13delegation\
    ResponsesB\x1b\xaa\xdf\x1f\x13DelegationResponses\xc8\xde\x1f\0\x12G\n\n\
    pagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponse\
    R\npagination\"\x9a\x01\n)QueryValidatorUnbondingDelegationsRequest\x12%\
    \n\x0evalidator_addr\x18\x01\x20\x01(\tR\rvalidatorAddr\x12F\n\npaginati\
    on\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagina\
    tion\"\xd9\x01\n*QueryValidatorUnbondingDelegationsResponse\x12b\n\x13un\
    bonding_responses\x18\x01\x20\x03(\x0b2+.cosmos.staking.v1beta1.Unbondin\
    gDelegationR\x12unbondingResponsesB\x04\xc8\xde\x1f\0\x12G\n\npagination\
    \x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npaginat\
    ion\"p\n\x16QueryDelegationRequest\x12%\n\x0edelegator_addr\x18\x01\x20\
    \x01(\tR\rdelegatorAddr\x12%\n\x0evalidator_addr\x18\x02\x20\x01(\tR\rva\
    lidatorAddr:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"v\n\x17QueryDelegationResp\
    onse\x12[\n\x13delegation_response\x18\x01\x20\x01(\x0b2*.cosmos.staking\
    .v1beta1.DelegationResponseR\x12delegationResponse\"y\n\x1fQueryUnbondin\
    gDelegationRequest\x12%\n\x0edelegator_addr\x18\x01\x20\x01(\tR\rdelegat\
    orAddr\x12%\n\x0evalidator_addr\x18\x02\x20\x01(\tR\rvalidatorAddr:\x08\
    \x88\xa0\x1f\0\xe8\xa0\x1f\0\"m\n\x20QueryUnbondingDelegationResponse\
    \x12I\n\x06unbond\x18\x01\x20\x01(\x0b2+.cosmos.staking.v1beta1.Unbondin\
    gDelegationR\x06unbondB\x04\xc8\xde\x1f\0\"\x9b\x01\n\x20QueryDelegatorD\
    elegationsRequest\x12%\n\x0edelegator_addr\x18\x01\x20\x01(\tR\rdelegato\
    rAddr\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta\
    1.PageRequestR\npagination:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\xd1\x01\n!\
    QueryDelegatorDelegationsResponse\x12c\n\x14delegation_responses\x18\x01\
    \x20\x03(\x0b2*.cosmos.staking.v1beta1.DelegationResponseR\x13delegation\
    ResponsesB\x04\xc8\xde\x1f\0\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.c\
    osmos.base.query.v1beta1.PageResponseR\npagination\"\xa4\x01\n)QueryDele\
    gatorUnbondingDelegationsRequest\x12%\n\x0edelegator_addr\x18\x01\x20\
    \x01(\tR\rdelegatorAddr\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmos\
    .base.query.v1beta1.PageRequestR\npagination:\x08\x88\xa0\x1f\0\xe8\xa0\
    \x1f\0\"\xd9\x01\n*QueryDelegatorUnbondingDelegationsResponse\x12b\n\x13\
    unbonding_responses\x18\x01\x20\x03(\x0b2+.cosmos.staking.v1beta1.Unbond\
    ingDelegationR\x12unbondingResponsesB\x04\xc8\xde\x1f\0\x12G\n\npaginati\
    on\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagin\
    ation\"\xf0\x01\n\x19QueryRedelegationsRequest\x12%\n\x0edelegator_addr\
    \x18\x01\x20\x01(\tR\rdelegatorAddr\x12,\n\x12src_validator_addr\x18\x02\
    \x20\x01(\tR\x10srcValidatorAddr\x12,\n\x12dst_validator_addr\x18\x03\
    \x20\x01(\tR\x10dstValidatorAddr\x12F\n\npagination\x18\x04\x20\x01(\x0b\
    2&.cosmos.base.query.v1beta1.PageRequestR\npagination:\x08\x88\xa0\x1f\0\
    \xe8\xa0\x1f\0\"\xd0\x01\n\x1aQueryRedelegationsResponse\x12i\n\x16redel\
    egation_responses\x18\x01\x20\x03(\x0b2,.cosmos.staking.v1beta1.Redelega\
    tionResponseR\x15redelegationResponsesB\x04\xc8\xde\x1f\0\x12G\n\npagina\
    tion\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npag\
    ination\"\x9a\x01\n\x1fQueryDelegatorValidatorsRequest\x12%\n\x0edelegat\
    or_addr\x18\x01\x20\x01(\tR\rdelegatorAddr\x12F\n\npagination\x18\x02\
    \x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination:\x08\
    \x88\xa0\x1f\0\xe8\xa0\x1f\0\"\xb4\x01\n\x20QueryDelegatorValidatorsResp\
    onse\x12G\n\nvalidators\x18\x01\x20\x03(\x0b2!.cosmos.staking.v1beta1.Va\
    lidatorR\nvalidatorsB\x04\xc8\xde\x1f\0\x12G\n\npagination\x18\x02\x20\
    \x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\"x\n\x1e\
    QueryDelegatorValidatorRequest\x12%\n\x0edelegator_addr\x18\x01\x20\x01(\
    \tR\rdelegatorAddr\x12%\n\x0evalidator_addr\x18\x02\x20\x01(\tR\rvalidat\
    orAddr:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"h\n\x1fQueryDelegatorValidatorR\
    esponse\x12E\n\tvalidator\x18\x01\x20\x01(\x0b2!.cosmos.staking.v1beta1.\
    ValidatorR\tvalidatorB\x04\xc8\xde\x1f\0\"4\n\x1aQueryHistoricalInfoRequ\
    est\x12\x16\n\x06height\x18\x01\x20\x01(\x03R\x06height\"Y\n\x1bQueryHis\
    toricalInfoResponse\x12:\n\x04hist\x18\x01\x20\x01(\x0b2&.cosmos.staking\
    .v1beta1.HistoricalInfoR\x04hist\"\x12\n\x10QueryPoolRequest\"K\n\x11Que\
    ryPoolResponse\x126\n\x04pool\x18\x01\x20\x01(\x0b2\x1c.cosmos.staking.v\
    1beta1.PoolR\x04poolB\x04\xc8\xde\x1f\0\"\x14\n\x12QueryParamsRequest\"S\
    \n\x13QueryParamsResponse\x12<\n\x06params\x18\x01\x20\x01(\x0b2\x1e.cos\
    mos.staking.v1beta1.ParamsR\x06paramsB\x04\xc8\xde\x1f\02\xea\x15\n\x05Q\
    uery\x12\x99\x01\n\nValidators\x12..cosmos.staking.v1beta1.QueryValidato\
    rsRequest\x1a/.cosmos.staking.v1beta1.QueryValidatorsResponse\"*\x82\xd3\
    \xe4\x93\x02$\x12\"/cosmos/staking/v1beta1/validators\x12\xa7\x01\n\tVal\
    idator\x12-.cosmos.staking.v1beta1.QueryValidatorRequest\x1a..cosmos.sta\
    king.v1beta1.QueryValidatorResponse\";\x82\xd3\xe4\x93\x025\x123/cosmos/\
    staking/v1beta1/validators/{validator_addr}\x12\xd4\x01\n\x14ValidatorDe\
    legations\x128.cosmos.staking.v1beta1.QueryValidatorDelegationsRequest\
    \x1a9.cosmos.staking.v1beta1.QueryValidatorDelegationsResponse\"G\x82\
    \xd3\xe4\x93\x02A\x12?/cosmos/staking/v1beta1/validators/{validator_addr\
    }/delegations\x12\xf9\x01\n\x1dValidatorUnbondingDelegations\x12A.cosmos\
    .staking.v1beta1.QueryValidatorUnbondingDelegationsRequest\x1aB.cosmos.s\
    taking.v1beta1.QueryValidatorUnbondingDelegationsResponse\"Q\x82\xd3\xe4\
    \x93\x02K\x12I/cosmos/staking/v1beta1/validators/{validator_addr}/unbond\
    ing_delegations\x12\xc7\x01\n\nDelegation\x12..cosmos.staking.v1beta1.Qu\
    eryDelegationRequest\x1a/.cosmos.staking.v1beta1.QueryDelegationResponse\
    \"X\x82\xd3\xe4\x93\x02R\x12P/cosmos/staking/v1beta1/validators/{validat\
    or_addr}/delegations/{delegator_addr}\x12\xf7\x01\n\x13UnbondingDelegati\
    on\x127.cosmos.staking.v1beta1.QueryUnbondingDelegationRequest\x1a8.cosm\
    os.staking.v1beta1.QueryUnbondingDelegationResponse\"m\x82\xd3\xe4\x93\
    \x02g\x12e/cosmos/staking/v1beta1/validators/{validator_addr}/delegation\
    s/{delegator_addr}/unbonding_delegation\x12\xc9\x01\n\x14DelegatorDelega\
    tions\x128.cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest\x1a9.\
    cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse\"<\x82\xd3\xe4\
    \x93\x026\x124/cosmos/staking/v1beta1/delegations/{delegator_addr}\x12\
    \xf9\x01\n\x1dDelegatorUnbondingDelegations\x12A.cosmos.staking.v1beta1.\
    QueryDelegatorUnbondingDelegationsRequest\x1aB.cosmos.staking.v1beta1.Qu\
    eryDelegatorUnbondingDelegationsResponse\"Q\x82\xd3\xe4\x93\x02K\x12I/co\
    smos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations\
    \x12\xc1\x01\n\rRedelegations\x121.cosmos.staking.v1beta1.QueryRedelegat\
    ionsRequest\x1a2.cosmos.staking.v1beta1.QueryRedelegationsResponse\"I\
    \x82\xd3\xe4\x93\x02C\x12A/cosmos/staking/v1beta1/delegators/{delegator_\
    addr}/redelegations\x12\xd0\x01\n\x13DelegatorValidators\x127.cosmos.sta\
    king.v1beta1.QueryDelegatorValidatorsRequest\x1a8.cosmos.staking.v1beta1\
    .QueryDelegatorValidatorsResponse\"F\x82\xd3\xe4\x93\x02@\x12>/cosmos/st\
    aking/v1beta1/delegators/{delegator_addr}/validators\x12\xde\x01\n\x12De\
    legatorValidator\x126.cosmos.staking.v1beta1.QueryDelegatorValidatorRequ\
    est\x1a7.cosmos.staking.v1beta1.QueryDelegatorValidatorResponse\"W\x82\
    \xd3\xe4\x93\x02Q\x12O/cosmos/staking/v1beta1/delegators/{delegator_addr\
    }/validators/{validator_addr}\x12\xb3\x01\n\x0eHistoricalInfo\x122.cosmo\
    s.staking.v1beta1.QueryHistoricalInfoRequest\x1a3.cosmos.staking.v1beta1\
    .QueryHistoricalInfoResponse\"8\x82\xd3\xe4\x93\x022\x120/cosmos/staking\
    /v1beta1/historical_info/{height}\x12\x81\x01\n\x04Pool\x12(.cosmos.stak\
    ing.v1beta1.QueryPoolRequest\x1a).cosmos.staking.v1beta1.QueryPoolRespon\
    se\"$\x82\xd3\xe4\x93\x02\x1e\x12\x1c/cosmos/staking/v1beta1/pool\x12\
    \x89\x01\n\x06Params\x12*.cosmos.staking.v1beta1.QueryParamsRequest\x1a+\
    .cosmos.staking.v1beta1.QueryParamsResponse\"&\x82\xd3\xe4\x93\x02\x20\
    \x12\x1e/cosmos/staking/v1beta1/paramsB.Z,github.com/cosmos/cosmos-sdk/x\
    /staking/typesb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
