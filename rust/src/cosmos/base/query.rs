// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cosmos/base/tendermint/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct GetValidatorSetByHeightRequest {
    // message fields
    pub height: i64,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorSetByHeightRequest {
    fn default() -> &'a GetValidatorSetByHeightRequest {
        <GetValidatorSetByHeightRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorSetByHeightRequest {
    pub fn new() -> GetValidatorSetByHeightRequest {
        ::std::default::Default::default()
    }

    // int64 height = 1;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 2;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for GetValidatorSetByHeightRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorSetByHeightRequest {
        GetValidatorSetByHeightRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "height",
                |m: &GetValidatorSetByHeightRequest| { &m.height },
                |m: &mut GetValidatorSetByHeightRequest| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &GetValidatorSetByHeightRequest| { &m.pagination },
                |m: &mut GetValidatorSetByHeightRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetValidatorSetByHeightRequest>(
                "GetValidatorSetByHeightRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetValidatorSetByHeightRequest {
        static instance: ::protobuf::rt::LazyV2<GetValidatorSetByHeightRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorSetByHeightRequest::new)
    }
}

impl ::protobuf::Clear for GetValidatorSetByHeightRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetValidatorSetByHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorSetByHeightRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetValidatorSetByHeightResponse {
    // message fields
    pub block_height: i64,
    pub validators: ::protobuf::RepeatedField<Validator>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorSetByHeightResponse {
    fn default() -> &'a GetValidatorSetByHeightResponse {
        <GetValidatorSetByHeightResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorSetByHeightResponse {
    pub fn new() -> GetValidatorSetByHeightResponse {
        ::std::default::Default::default()
    }

    // int64 block_height = 1;


    pub fn get_block_height(&self) -> i64 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i64) {
        self.block_height = v;
    }

    // repeated .cosmos.base.tendermint.v1beta1.Validator validators = 2;


    pub fn get_validators(&self) -> &[Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 3;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for GetValidatorSetByHeightResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_height != 0 {
            os.write_int64(1, self.block_height)?;
        }
        for v in &self.validators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorSetByHeightResponse {
        GetValidatorSetByHeightResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "block_height",
                |m: &GetValidatorSetByHeightResponse| { &m.block_height },
                |m: &mut GetValidatorSetByHeightResponse| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "validators",
                |m: &GetValidatorSetByHeightResponse| { &m.validators },
                |m: &mut GetValidatorSetByHeightResponse| { &mut m.validators },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &GetValidatorSetByHeightResponse| { &m.pagination },
                |m: &mut GetValidatorSetByHeightResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetValidatorSetByHeightResponse>(
                "GetValidatorSetByHeightResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetValidatorSetByHeightResponse {
        static instance: ::protobuf::rt::LazyV2<GetValidatorSetByHeightResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorSetByHeightResponse::new)
    }
}

impl ::protobuf::Clear for GetValidatorSetByHeightResponse {
    fn clear(&mut self) {
        self.block_height = 0;
        self.validators.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetValidatorSetByHeightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorSetByHeightResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLatestValidatorSetRequest {
    // message fields
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLatestValidatorSetRequest {
    fn default() -> &'a GetLatestValidatorSetRequest {
        <GetLatestValidatorSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestValidatorSetRequest {
    pub fn new() -> GetLatestValidatorSetRequest {
        ::std::default::Default::default()
    }

    // .cosmos.base.query.v1beta1.PageRequest pagination = 1;


    pub fn get_pagination(&self) -> &super::pagination::PageRequest {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageRequest) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageRequest {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageRequest {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageRequest::new())
    }
}

impl ::protobuf::Message for GetLatestValidatorSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLatestValidatorSetRequest {
        GetLatestValidatorSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageRequest>>(
                "pagination",
                |m: &GetLatestValidatorSetRequest| { &m.pagination },
                |m: &mut GetLatestValidatorSetRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLatestValidatorSetRequest>(
                "GetLatestValidatorSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLatestValidatorSetRequest {
        static instance: ::protobuf::rt::LazyV2<GetLatestValidatorSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLatestValidatorSetRequest::new)
    }
}

impl ::protobuf::Clear for GetLatestValidatorSetRequest {
    fn clear(&mut self) {
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLatestValidatorSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestValidatorSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLatestValidatorSetResponse {
    // message fields
    pub block_height: i64,
    pub validators: ::protobuf::RepeatedField<Validator>,
    pub pagination: ::protobuf::SingularPtrField<super::pagination::PageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLatestValidatorSetResponse {
    fn default() -> &'a GetLatestValidatorSetResponse {
        <GetLatestValidatorSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestValidatorSetResponse {
    pub fn new() -> GetLatestValidatorSetResponse {
        ::std::default::Default::default()
    }

    // int64 block_height = 1;


    pub fn get_block_height(&self) -> i64 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i64) {
        self.block_height = v;
    }

    // repeated .cosmos.base.tendermint.v1beta1.Validator validators = 2;


    pub fn get_validators(&self) -> &[Validator] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }

    // .cosmos.base.query.v1beta1.PageResponse pagination = 3;


    pub fn get_pagination(&self) -> &super::pagination::PageResponse {
        self.pagination.as_ref().unwrap_or_else(|| <super::pagination::PageResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: super::pagination::PageResponse) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut super::pagination::PageResponse {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> super::pagination::PageResponse {
        self.pagination.take().unwrap_or_else(|| super::pagination::PageResponse::new())
    }
}

impl ::protobuf::Message for GetLatestValidatorSetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.validators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.validators)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.validators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_height != 0 {
            os.write_int64(1, self.block_height)?;
        }
        for v in &self.validators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLatestValidatorSetResponse {
        GetLatestValidatorSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "block_height",
                |m: &GetLatestValidatorSetResponse| { &m.block_height },
                |m: &mut GetLatestValidatorSetResponse| { &mut m.block_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validator>>(
                "validators",
                |m: &GetLatestValidatorSetResponse| { &m.validators },
                |m: &mut GetLatestValidatorSetResponse| { &mut m.validators },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::pagination::PageResponse>>(
                "pagination",
                |m: &GetLatestValidatorSetResponse| { &m.pagination },
                |m: &mut GetLatestValidatorSetResponse| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLatestValidatorSetResponse>(
                "GetLatestValidatorSetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLatestValidatorSetResponse {
        static instance: ::protobuf::rt::LazyV2<GetLatestValidatorSetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLatestValidatorSetResponse::new)
    }
}

impl ::protobuf::Clear for GetLatestValidatorSetResponse {
    fn clear(&mut self) {
        self.block_height = 0;
        self.validators.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLatestValidatorSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestValidatorSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Validator {
    // message fields
    pub address: ::std::string::String,
    pub pub_key: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub voting_power: i64,
    pub proposer_priority: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // .google.protobuf.Any pub_key = 2;


    pub fn get_pub_key(&self) -> &::protobuf::well_known_types::Any {
        self.pub_key.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    pub fn has_pub_key(&self) -> bool {
        self.pub_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::protobuf::well_known_types::Any) {
        self.pub_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.pub_key.is_none() {
            self.pub_key.set_default();
        }
        self.pub_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::protobuf::well_known_types::Any {
        self.pub_key.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // int64 voting_power = 3;


    pub fn get_voting_power(&self) -> i64 {
        self.voting_power
    }
    pub fn clear_voting_power(&mut self) {
        self.voting_power = 0;
    }

    // Param is passed by value, moved
    pub fn set_voting_power(&mut self, v: i64) {
        self.voting_power = v;
    }

    // int64 proposer_priority = 4;


    pub fn get_proposer_priority(&self) -> i64 {
        self.proposer_priority
    }
    pub fn clear_proposer_priority(&mut self) {
        self.proposer_priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposer_priority(&mut self, v: i64) {
        self.proposer_priority = v;
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        for v in &self.pub_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.voting_power = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposer_priority = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if let Some(ref v) = self.pub_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.voting_power != 0 {
            my_size += ::protobuf::rt::value_size(3, self.voting_power, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.proposer_priority != 0 {
            my_size += ::protobuf::rt::value_size(4, self.proposer_priority, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if let Some(ref v) = self.pub_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.voting_power != 0 {
            os.write_int64(3, self.voting_power)?;
        }
        if self.proposer_priority != 0 {
            os.write_int64(4, self.proposer_priority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Validator| { &m.address },
                |m: &mut Validator| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "pub_key",
                |m: &Validator| { &m.pub_key },
                |m: &mut Validator| { &mut m.pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "voting_power",
                |m: &Validator| { &m.voting_power },
                |m: &mut Validator| { &mut m.voting_power },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "proposer_priority",
                |m: &Validator| { &m.proposer_priority },
                |m: &mut Validator| { &mut m.proposer_priority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Validator>(
                "Validator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.address.clear();
        self.pub_key.clear();
        self.voting_power = 0;
        self.proposer_priority = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockByHeightRequest {
    // message fields
    pub height: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockByHeightRequest {
    fn default() -> &'a GetBlockByHeightRequest {
        <GetBlockByHeightRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockByHeightRequest {
    pub fn new() -> GetBlockByHeightRequest {
        ::std::default::Default::default()
    }

    // int64 height = 1;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }
}

impl ::protobuf::Message for GetBlockByHeightRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int64(1, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockByHeightRequest {
        GetBlockByHeightRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "height",
                |m: &GetBlockByHeightRequest| { &m.height },
                |m: &mut GetBlockByHeightRequest| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockByHeightRequest>(
                "GetBlockByHeightRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockByHeightRequest {
        static instance: ::protobuf::rt::LazyV2<GetBlockByHeightRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockByHeightRequest::new)
    }
}

impl ::protobuf::Clear for GetBlockByHeightRequest {
    fn clear(&mut self) {
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockByHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockByHeightRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockByHeightResponse {
    // message fields
    pub block_id: ::protobuf::SingularPtrField<crate::tendermint::types::types::BlockID>,
    pub block: ::protobuf::SingularPtrField<super::block::Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockByHeightResponse {
    fn default() -> &'a GetBlockByHeightResponse {
        <GetBlockByHeightResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockByHeightResponse {
    pub fn new() -> GetBlockByHeightResponse {
        ::std::default::Default::default()
    }

    // .tendermint.types.BlockID block_id = 1;


    pub fn get_block_id(&self) -> &crate::tendermint::types::types::BlockID {
        self.block_id.as_ref().unwrap_or_else(|| <crate::tendermint::types::types::BlockID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block_id(&mut self) {
        self.block_id.clear();
    }

    pub fn has_block_id(&self) -> bool {
        self.block_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_id(&mut self, v: crate::tendermint::types::types::BlockID) {
        self.block_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_id(&mut self) -> &mut crate::tendermint::types::types::BlockID{
        if self.block_id.is_none() {
            self.block_id.set_default();
        }
        self.block_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_id(&mut self) -> crate::tendermint::types::types::BlockID {
        self.block_id.take().unwrap_or_else(|| crate::tendermint::types::types::BlockID::new())
    }

    // .tendermint.types.Block block = 2;


    pub fn get_block(&self) -> &super::block::Block {
        self.block.as_ref().unwrap_or_else(|| <super::block::Block as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::block::Block) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::block::Block {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::block::Block {
        self.block.take().unwrap_or_else(|| super::block::Block::new())
    }
}

impl ::protobuf::Message for GetBlockByHeightResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.block_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockByHeightResponse {
        GetBlockByHeightResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<crate::tendermint::types::types::BlockID>>(
                "block_id",
                |m: &GetBlockByHeightResponse| { &m.block_id },
                |m: &mut GetBlockByHeightResponse| { &mut m.block_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                "block",
                |m: &GetBlockByHeightResponse| { &m.block },
                |m: &mut GetBlockByHeightResponse| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockByHeightResponse>(
                "GetBlockByHeightResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockByHeightResponse {
        static instance: ::protobuf::rt::LazyV2<GetBlockByHeightResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockByHeightResponse::new)
    }
}

impl ::protobuf::Clear for GetBlockByHeightResponse {
    fn clear(&mut self) {
        self.block_id.clear();
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockByHeightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockByHeightResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLatestBlockRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLatestBlockRequest {
    fn default() -> &'a GetLatestBlockRequest {
        <GetLatestBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestBlockRequest {
    pub fn new() -> GetLatestBlockRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLatestBlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLatestBlockRequest {
        GetLatestBlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLatestBlockRequest>(
                "GetLatestBlockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLatestBlockRequest {
        static instance: ::protobuf::rt::LazyV2<GetLatestBlockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLatestBlockRequest::new)
    }
}

impl ::protobuf::Clear for GetLatestBlockRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLatestBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestBlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLatestBlockResponse {
    // message fields
    pub block_id: ::protobuf::SingularPtrField<crate::tendermint::types::types::BlockID>,
    pub block: ::protobuf::SingularPtrField<super::block::Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLatestBlockResponse {
    fn default() -> &'a GetLatestBlockResponse {
        <GetLatestBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLatestBlockResponse {
    pub fn new() -> GetLatestBlockResponse {
        ::std::default::Default::default()
    }

    // .tendermint.types.BlockID block_id = 1;


    pub fn get_block_id(&self) -> &crate::tendermint::types::types::BlockID {
        self.block_id.as_ref().unwrap_or_else(|| <crate::tendermint::types::types::BlockID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block_id(&mut self) {
        self.block_id.clear();
    }

    pub fn has_block_id(&self) -> bool {
        self.block_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_id(&mut self, v: crate::tendermint::types::types::BlockID) {
        self.block_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_id(&mut self) -> &mut crate::tendermint::types::types::BlockID {
        if self.block_id.is_none() {
            self.block_id.set_default();
        }
        self.block_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_id(&mut self) -> crate::tendermint::types::types::BlockID {
        self.block_id.take().unwrap_or_else(|| crate::tendermint::types::types::BlockID::new())
    }

    // .tendermint.types.Block block = 2;


    pub fn get_block(&self) -> &super::block::Block {
        self.block.as_ref().unwrap_or_else(|| <super::block::Block as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::block::Block) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::block::Block {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::block::Block {
        self.block.take().unwrap_or_else(|| super::block::Block::new())
    }
}

impl ::protobuf::Message for GetLatestBlockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.block_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLatestBlockResponse {
        GetLatestBlockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<crate::tendermint::types::types::BlockID>>(
                "block_id",
                |m: &GetLatestBlockResponse| { &m.block_id },
                |m: &mut GetLatestBlockResponse| { &mut m.block_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                "block",
                |m: &GetLatestBlockResponse| { &m.block },
                |m: &mut GetLatestBlockResponse| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLatestBlockResponse>(
                "GetLatestBlockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLatestBlockResponse {
        static instance: ::protobuf::rt::LazyV2<GetLatestBlockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLatestBlockResponse::new)
    }
}

impl ::protobuf::Clear for GetLatestBlockResponse {
    fn clear(&mut self) {
        self.block_id.clear();
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLatestBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLatestBlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSyncingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSyncingRequest {
    fn default() -> &'a GetSyncingRequest {
        <GetSyncingRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSyncingRequest {
    pub fn new() -> GetSyncingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSyncingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSyncingRequest {
        GetSyncingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSyncingRequest>(
                "GetSyncingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSyncingRequest {
        static instance: ::protobuf::rt::LazyV2<GetSyncingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSyncingRequest::new)
    }
}

impl ::protobuf::Clear for GetSyncingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSyncingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSyncingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSyncingResponse {
    // message fields
    pub syncing: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSyncingResponse {
    fn default() -> &'a GetSyncingResponse {
        <GetSyncingResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSyncingResponse {
    pub fn new() -> GetSyncingResponse {
        ::std::default::Default::default()
    }

    // bool syncing = 1;


    pub fn get_syncing(&self) -> bool {
        self.syncing
    }
    pub fn clear_syncing(&mut self) {
        self.syncing = false;
    }

    // Param is passed by value, moved
    pub fn set_syncing(&mut self, v: bool) {
        self.syncing = v;
    }
}

impl ::protobuf::Message for GetSyncingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.syncing != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.syncing != false {
            os.write_bool(1, self.syncing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSyncingResponse {
        GetSyncingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "syncing",
                |m: &GetSyncingResponse| { &m.syncing },
                |m: &mut GetSyncingResponse| { &mut m.syncing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSyncingResponse>(
                "GetSyncingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSyncingResponse {
        static instance: ::protobuf::rt::LazyV2<GetSyncingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSyncingResponse::new)
    }
}

impl ::protobuf::Clear for GetSyncingResponse {
    fn clear(&mut self) {
        self.syncing = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSyncingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSyncingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNodeInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNodeInfoRequest {
    fn default() -> &'a GetNodeInfoRequest {
        <GetNodeInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetNodeInfoRequest {
    pub fn new() -> GetNodeInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetNodeInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNodeInfoRequest {
        GetNodeInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNodeInfoRequest>(
                "GetNodeInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNodeInfoRequest {
        static instance: ::protobuf::rt::LazyV2<GetNodeInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNodeInfoRequest::new)
    }
}

impl ::protobuf::Clear for GetNodeInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNodeInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodeInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNodeInfoResponse {
    // message fields
    pub default_node_info: ::protobuf::SingularPtrField<super::DefaultNodeInfo>,
    pub application_version: ::protobuf::SingularPtrField<VersionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNodeInfoResponse {
    fn default() -> &'a GetNodeInfoResponse {
        <GetNodeInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNodeInfoResponse {
    pub fn new() -> GetNodeInfoResponse {
        ::std::default::Default::default()
    }

    // .tendermint.p2p.DefaultNodeInfo default_node_info = 1;


    pub fn get_default_node_info(&self) -> &super::DefaultNodeInfo {
        self.default_node_info.as_ref().unwrap_or_else(|| <super::DefaultNodeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_node_info(&mut self) {
        self.default_node_info.clear();
    }

    pub fn has_default_node_info(&self) -> bool {
        self.default_node_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_node_info(&mut self, v: super::DefaultNodeInfo) {
        self.default_node_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_node_info(&mut self) -> &mut super::DefaultNodeInfo {
        if self.default_node_info.is_none() {
            self.default_node_info.set_default();
        }
        self.default_node_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_node_info(&mut self) -> super::DefaultNodeInfo {
        self.default_node_info.take().unwrap_or_else(|| super::DefaultNodeInfo::new())
    }

    // .cosmos.base.tendermint.v1beta1.VersionInfo application_version = 2;


    pub fn get_application_version(&self) -> &VersionInfo {
        self.application_version.as_ref().unwrap_or_else(|| <VersionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_application_version(&mut self) {
        self.application_version.clear();
    }

    pub fn has_application_version(&self) -> bool {
        self.application_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_application_version(&mut self, v: VersionInfo) {
        self.application_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application_version(&mut self) -> &mut VersionInfo {
        if self.application_version.is_none() {
            self.application_version.set_default();
        }
        self.application_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_application_version(&mut self) -> VersionInfo {
        self.application_version.take().unwrap_or_else(|| VersionInfo::new())
    }
}

impl ::protobuf::Message for GetNodeInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.default_node_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.application_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_node_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.application_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.default_node_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.application_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.default_node_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.application_version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNodeInfoResponse {
        GetNodeInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::DefaultNodeInfo>>(
                "default_node_info",
                |m: &GetNodeInfoResponse| { &m.default_node_info },
                |m: &mut GetNodeInfoResponse| { &mut m.default_node_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VersionInfo>>(
                "application_version",
                |m: &GetNodeInfoResponse| { &m.application_version },
                |m: &mut GetNodeInfoResponse| { &mut m.application_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNodeInfoResponse>(
                "GetNodeInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNodeInfoResponse {
        static instance: ::protobuf::rt::LazyV2<GetNodeInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNodeInfoResponse::new)
    }
}

impl ::protobuf::Clear for GetNodeInfoResponse {
    fn clear(&mut self) {
        self.default_node_info.clear();
        self.application_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNodeInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodeInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionInfo {
    // message fields
    pub name: ::std::string::String,
    pub app_name: ::std::string::String,
    pub version: ::std::string::String,
    pub git_commit: ::std::string::String,
    pub build_tags: ::std::string::String,
    pub go_version: ::std::string::String,
    pub build_deps: ::protobuf::RepeatedField<Module>,
    pub cosmos_sdk_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionInfo {
    fn default() -> &'a VersionInfo {
        <VersionInfo as ::protobuf::Message>::default_instance()
    }
}

impl VersionInfo {
    pub fn new() -> VersionInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string app_name = 2;


    pub fn get_app_name(&self) -> &str {
        &self.app_name
    }
    pub fn clear_app_name(&mut self) {
        self.app_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        &mut self.app_name
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_name, ::std::string::String::new())
    }

    // string version = 3;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string git_commit = 4;


    pub fn get_git_commit(&self) -> &str {
        &self.git_commit
    }
    pub fn clear_git_commit(&mut self) {
        self.git_commit.clear();
    }

    // Param is passed by value, moved
    pub fn set_git_commit(&mut self, v: ::std::string::String) {
        self.git_commit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_git_commit(&mut self) -> &mut ::std::string::String {
        &mut self.git_commit
    }

    // Take field
    pub fn take_git_commit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.git_commit, ::std::string::String::new())
    }

    // string build_tags = 5;


    pub fn get_build_tags(&self) -> &str {
        &self.build_tags
    }
    pub fn clear_build_tags(&mut self) {
        self.build_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_build_tags(&mut self, v: ::std::string::String) {
        self.build_tags = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_tags(&mut self) -> &mut ::std::string::String {
        &mut self.build_tags
    }

    // Take field
    pub fn take_build_tags(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.build_tags, ::std::string::String::new())
    }

    // string go_version = 6;


    pub fn get_go_version(&self) -> &str {
        &self.go_version
    }
    pub fn clear_go_version(&mut self) {
        self.go_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_go_version(&mut self, v: ::std::string::String) {
        self.go_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_go_version(&mut self) -> &mut ::std::string::String {
        &mut self.go_version
    }

    // Take field
    pub fn take_go_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.go_version, ::std::string::String::new())
    }

    // repeated .cosmos.base.tendermint.v1beta1.Module build_deps = 7;


    pub fn get_build_deps(&self) -> &[Module] {
        &self.build_deps
    }
    pub fn clear_build_deps(&mut self) {
        self.build_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_build_deps(&mut self, v: ::protobuf::RepeatedField<Module>) {
        self.build_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_build_deps(&mut self) -> &mut ::protobuf::RepeatedField<Module> {
        &mut self.build_deps
    }

    // Take field
    pub fn take_build_deps(&mut self) -> ::protobuf::RepeatedField<Module> {
        ::std::mem::replace(&mut self.build_deps, ::protobuf::RepeatedField::new())
    }

    // string cosmos_sdk_version = 8;


    pub fn get_cosmos_sdk_version(&self) -> &str {
        &self.cosmos_sdk_version
    }
    pub fn clear_cosmos_sdk_version(&mut self) {
        self.cosmos_sdk_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_cosmos_sdk_version(&mut self, v: ::std::string::String) {
        self.cosmos_sdk_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cosmos_sdk_version(&mut self) -> &mut ::std::string::String {
        &mut self.cosmos_sdk_version
    }

    // Take field
    pub fn take_cosmos_sdk_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cosmos_sdk_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.build_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.git_commit)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.build_tags)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.go_version)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.build_deps)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cosmos_sdk_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.app_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        if !self.git_commit.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.git_commit);
        }
        if !self.build_tags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.build_tags);
        }
        if !self.go_version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.go_version);
        }
        for value in &self.build_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cosmos_sdk_version.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.cosmos_sdk_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.app_name.is_empty() {
            os.write_string(2, &self.app_name)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        if !self.git_commit.is_empty() {
            os.write_string(4, &self.git_commit)?;
        }
        if !self.build_tags.is_empty() {
            os.write_string(5, &self.build_tags)?;
        }
        if !self.go_version.is_empty() {
            os.write_string(6, &self.go_version)?;
        }
        for v in &self.build_deps {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cosmos_sdk_version.is_empty() {
            os.write_string(8, &self.cosmos_sdk_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionInfo {
        VersionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VersionInfo| { &m.name },
                |m: &mut VersionInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_name",
                |m: &VersionInfo| { &m.app_name },
                |m: &mut VersionInfo| { &mut m.app_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &VersionInfo| { &m.version },
                |m: &mut VersionInfo| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "git_commit",
                |m: &VersionInfo| { &m.git_commit },
                |m: &mut VersionInfo| { &mut m.git_commit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "build_tags",
                |m: &VersionInfo| { &m.build_tags },
                |m: &mut VersionInfo| { &mut m.build_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "go_version",
                |m: &VersionInfo| { &m.go_version },
                |m: &mut VersionInfo| { &mut m.go_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Module>>(
                "build_deps",
                |m: &VersionInfo| { &m.build_deps },
                |m: &mut VersionInfo| { &mut m.build_deps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cosmos_sdk_version",
                |m: &VersionInfo| { &m.cosmos_sdk_version },
                |m: &mut VersionInfo| { &mut m.cosmos_sdk_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionInfo>(
                "VersionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VersionInfo {
        static instance: ::protobuf::rt::LazyV2<VersionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionInfo::new)
    }
}

impl ::protobuf::Clear for VersionInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.app_name.clear();
        self.version.clear();
        self.git_commit.clear();
        self.build_tags.clear();
        self.go_version.clear();
        self.build_deps.clear();
        self.cosmos_sdk_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Module {
    // message fields
    pub path: ::std::string::String,
    pub version: ::std::string::String,
    pub sum: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string sum = 3;


    pub fn get_sum(&self) -> &str {
        &self.sum
    }
    pub fn clear_sum(&mut self) {
        self.sum.clear();
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: ::std::string::String) {
        self.sum = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sum(&mut self) -> &mut ::std::string::String {
        &mut self.sum
    }

    // Take field
    pub fn take_sum(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sum, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Module {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sum)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.sum.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.sum.is_empty() {
            os.write_string(3, &self.sum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Module {
        Module::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &Module| { &m.path },
                |m: &mut Module| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Module| { &m.version },
                |m: &mut Module| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sum",
                |m: &Module| { &m.sum },
                |m: &mut Module| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Module>(
                "Module",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::LazyV2<Module> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Module::new)
    }
}

impl ::protobuf::Clear for Module {
    fn clear(&mut self) {
        self.path.clear();
        self.version.clear();
        self.sum.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*cosmos/base/tendermint/v1beta1/query.proto\x12\x1ecosmos.base.tenderm\
    int.v1beta1\x1a\x14gogoproto/gogo.proto\x1a\x19google/protobuf/any.proto\
    \x1a\x1cgoogle/api/annotations.proto\x1a\x1atendermint/p2p/types.proto\
    \x1a\x1ctendermint/types/block.proto\x1a\x1ctendermint/types/types.proto\
    \x1a*cosmos/base/query/v1beta1/pagination.proto\x1a\x19cosmos_proto/cosm\
    os.proto\"\x80\x01\n\x1eGetValidatorSetByHeightRequest\x12\x16\n\x06heig\
    ht\x18\x01\x20\x01(\x03R\x06height\x12F\n\npagination\x18\x02\x20\x01(\
    \x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination\"\xd8\x01\n\
    \x1fGetValidatorSetByHeightResponse\x12!\n\x0cblock_height\x18\x01\x20\
    \x01(\x03R\x0bblockHeight\x12I\n\nvalidators\x18\x02\x20\x03(\x0b2).cosm\
    os.base.tendermint.v1beta1.ValidatorR\nvalidators\x12G\n\npagination\x18\
    \x03\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\
    \"f\n\x1cGetLatestValidatorSetRequest\x12F\n\npagination\x18\x01\x20\x01\
    (\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination\"\xd6\x01\n\
    \x1dGetLatestValidatorSetResponse\x12!\n\x0cblock_height\x18\x01\x20\x01\
    (\x03R\x0bblockHeight\x12I\n\nvalidators\x18\x02\x20\x03(\x0b2).cosmos.b\
    ase.tendermint.v1beta1.ValidatorR\nvalidators\x12G\n\npagination\x18\x03\
    \x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\"\
    \xbe\x01\n\tValidator\x122\n\x07address\x18\x01\x20\x01(\tR\x07addressB\
    \x18\xd2\xb4-\x14cosmos.AddressString\x12-\n\x07pub_key\x18\x02\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\x06pubKey\x12!\n\x0cvoting_power\x18\x03\
    \x20\x01(\x03R\x0bvotingPower\x12+\n\x11proposer_priority\x18\x04\x20\
    \x01(\x03R\x10proposerPriority\"1\n\x17GetBlockByHeightRequest\x12\x16\n\
    \x06height\x18\x01\x20\x01(\x03R\x06height\"\x7f\n\x18GetBlockByHeightRe\
    sponse\x124\n\x08block_id\x18\x01\x20\x01(\x0b2\x19.tendermint.types.Blo\
    ckIDR\x07blockId\x12-\n\x05block\x18\x02\x20\x01(\x0b2\x17.tendermint.ty\
    pes.BlockR\x05block\"\x17\n\x15GetLatestBlockRequest\"}\n\x16GetLatestBl\
    ockResponse\x124\n\x08block_id\x18\x01\x20\x01(\x0b2\x19.tendermint.type\
    s.BlockIDR\x07blockId\x12-\n\x05block\x18\x02\x20\x01(\x0b2\x17.tendermi\
    nt.types.BlockR\x05block\"\x13\n\x11GetSyncingRequest\".\n\x12GetSyncing\
    Response\x12\x18\n\x07syncing\x18\x01\x20\x01(\x08R\x07syncing\"\x14\n\
    \x12GetNodeInfoRequest\"\xc0\x01\n\x13GetNodeInfoResponse\x12K\n\x11defa\
    ult_node_info\x18\x01\x20\x01(\x0b2\x1f.tendermint.p2p.DefaultNodeInfoR\
    \x0fdefaultNodeInfo\x12\\\n\x13application_version\x18\x02\x20\x01(\x0b2\
    +.cosmos.base.tendermint.v1beta1.VersionInfoR\x12applicationVersion\"\
    \xa8\x02\n\x0bVersionInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x19\n\x08app_name\x18\x02\x20\x01(\tR\x07appName\x12\x18\n\x07versi\
    on\x18\x03\x20\x01(\tR\x07version\x12\x1d\n\ngit_commit\x18\x04\x20\x01(\
    \tR\tgitCommit\x12\x1d\n\nbuild_tags\x18\x05\x20\x01(\tR\tbuildTags\x12\
    \x1d\n\ngo_version\x18\x06\x20\x01(\tR\tgoVersion\x12E\n\nbuild_deps\x18\
    \x07\x20\x03(\x0b2&.cosmos.base.tendermint.v1beta1.ModuleR\tbuildDeps\
    \x12,\n\x12cosmos_sdk_version\x18\x08\x20\x01(\tR\x10cosmosSdkVersion\"H\
    \n\x06Module\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x18\n\x07\
    version\x18\x02\x20\x01(\tR\x07version\x12\x10\n\x03sum\x18\x03\x20\x01(\
    \tR\x03sum2\x88\t\n\x07Service\x12\xa9\x01\n\x0bGetNodeInfo\x122.cosmos.\
    base.tendermint.v1beta1.GetNodeInfoRequest\x1a3.cosmos.base.tendermint.v\
    1beta1.GetNodeInfoResponse\"1\x82\xd3\xe4\x93\x02+\x12)/cosmos/base/tend\
    ermint/v1beta1/node_info\x12\xa4\x01\n\nGetSyncing\x121.cosmos.base.tend\
    ermint.v1beta1.GetSyncingRequest\x1a2.cosmos.base.tendermint.v1beta1.Get\
    SyncingResponse\"/\x82\xd3\xe4\x93\x02)\x12'/cosmos/base/tendermint/v1be\
    ta1/syncing\x12\xb6\x01\n\x0eGetLatestBlock\x125.cosmos.base.tendermint.\
    v1beta1.GetLatestBlockRequest\x1a6.cosmos.base.tendermint.v1beta1.GetLat\
    estBlockResponse\"5\x82\xd3\xe4\x93\x02/\x12-/cosmos/base/tendermint/v1b\
    eta1/blocks/latest\x12\xbe\x01\n\x10GetBlockByHeight\x127.cosmos.base.te\
    ndermint.v1beta1.GetBlockByHeightRequest\x1a8.cosmos.base.tendermint.v1b\
    eta1.GetBlockByHeightResponse\"7\x82\xd3\xe4\x93\x021\x12//cosmos/base/t\
    endermint/v1beta1/blocks/{height}\x12\xd2\x01\n\x15GetLatestValidatorSet\
    \x12<.cosmos.base.tendermint.v1beta1.GetLatestValidatorSetRequest\x1a=.c\
    osmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse\"<\x82\xd3\
    \xe4\x93\x026\x124/cosmos/base/tendermint/v1beta1/validatorsets/latest\
    \x12\xda\x01\n\x17GetValidatorSetByHeight\x12>.cosmos.base.tendermint.v1\
    beta1.GetValidatorSetByHeightRequest\x1a?.cosmos.base.tendermint.v1beta1\
    .GetValidatorSetByHeightResponse\">\x82\xd3\xe4\x93\x028\x126/cosmos/bas\
    e/tendermint/v1beta1/validatorsets/{height}B4Z2github.com/cosmos/cosmos-\
    sdk/client/grpc/tmserviceb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
