// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cosmos/base/reflection/v2alpha1/reflection.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct AppDescriptor {
    // message fields
    pub authn: ::protobuf::SingularPtrField<AuthnDescriptor>,
    pub chain: ::protobuf::SingularPtrField<ChainDescriptor>,
    pub codec: ::protobuf::SingularPtrField<CodecDescriptor>,
    pub configuration: ::protobuf::SingularPtrField<ConfigurationDescriptor>,
    pub query_services: ::protobuf::SingularPtrField<QueryServicesDescriptor>,
    pub tx: ::protobuf::SingularPtrField<TxDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDescriptor {
    fn default() -> &'a AppDescriptor {
        <AppDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl AppDescriptor {
    pub fn new() -> AppDescriptor {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;


    pub fn get_authn(&self) -> &AuthnDescriptor {
        self.authn.as_ref().unwrap_or_else(|| <AuthnDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authn(&mut self) {
        self.authn.clear();
    }

    pub fn has_authn(&self) -> bool {
        self.authn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authn(&mut self, v: AuthnDescriptor) {
        self.authn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authn(&mut self) -> &mut AuthnDescriptor {
        if self.authn.is_none() {
            self.authn.set_default();
        }
        self.authn.as_mut().unwrap()
    }

    // Take field
    pub fn take_authn(&mut self) -> AuthnDescriptor {
        self.authn.take().unwrap_or_else(|| AuthnDescriptor::new())
    }

    // .cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 2;


    pub fn get_chain(&self) -> &ChainDescriptor {
        self.chain.as_ref().unwrap_or_else(|| <ChainDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chain(&mut self) {
        self.chain.clear();
    }

    pub fn has_chain(&self) -> bool {
        self.chain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: ChainDescriptor) {
        self.chain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain(&mut self) -> &mut ChainDescriptor {
        if self.chain.is_none() {
            self.chain.set_default();
        }
        self.chain.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain(&mut self) -> ChainDescriptor {
        self.chain.take().unwrap_or_else(|| ChainDescriptor::new())
    }

    // .cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 3;


    pub fn get_codec(&self) -> &CodecDescriptor {
        self.codec.as_ref().unwrap_or_else(|| <CodecDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_codec(&mut self) {
        self.codec.clear();
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: CodecDescriptor) {
        self.codec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut CodecDescriptor {
        if self.codec.is_none() {
            self.codec.set_default();
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> CodecDescriptor {
        self.codec.take().unwrap_or_else(|| CodecDescriptor::new())
    }

    // .cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration = 4;


    pub fn get_configuration(&self) -> &ConfigurationDescriptor {
        self.configuration.as_ref().unwrap_or_else(|| <ConfigurationDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configuration(&mut self) {
        self.configuration.clear();
    }

    pub fn has_configuration(&self) -> bool {
        self.configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration(&mut self, v: ConfigurationDescriptor) {
        self.configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration(&mut self) -> &mut ConfigurationDescriptor {
        if self.configuration.is_none() {
            self.configuration.set_default();
        }
        self.configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration(&mut self) -> ConfigurationDescriptor {
        self.configuration.take().unwrap_or_else(|| ConfigurationDescriptor::new())
    }

    // .cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services = 5;


    pub fn get_query_services(&self) -> &QueryServicesDescriptor {
        self.query_services.as_ref().unwrap_or_else(|| <QueryServicesDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query_services(&mut self) {
        self.query_services.clear();
    }

    pub fn has_query_services(&self) -> bool {
        self.query_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_services(&mut self, v: QueryServicesDescriptor) {
        self.query_services = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_services(&mut self) -> &mut QueryServicesDescriptor {
        if self.query_services.is_none() {
            self.query_services.set_default();
        }
        self.query_services.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_services(&mut self) -> QueryServicesDescriptor {
        self.query_services.take().unwrap_or_else(|| QueryServicesDescriptor::new())
    }

    // .cosmos.base.reflection.v2alpha1.TxDescriptor tx = 6;


    pub fn get_tx(&self) -> &TxDescriptor {
        self.tx.as_ref().unwrap_or_else(|| <TxDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    pub fn has_tx(&self) -> bool {
        self.tx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: TxDescriptor) {
        self.tx = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx(&mut self) -> &mut TxDescriptor {
        if self.tx.is_none() {
            self.tx.set_default();
        }
        self.tx.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx(&mut self) -> TxDescriptor {
        self.tx.take().unwrap_or_else(|| TxDescriptor::new())
    }
}

impl ::protobuf::Message for AppDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.authn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.codec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query_services {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authn)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chain)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.codec)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configuration)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query_services)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.chain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.codec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query_services.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authn.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.chain.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.codec.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configuration.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query_services.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tx.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDescriptor {
        AppDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthnDescriptor>>(
                "authn",
                |m: &AppDescriptor| { &m.authn },
                |m: &mut AppDescriptor| { &mut m.authn },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainDescriptor>>(
                "chain",
                |m: &AppDescriptor| { &m.chain },
                |m: &mut AppDescriptor| { &mut m.chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodecDescriptor>>(
                "codec",
                |m: &AppDescriptor| { &m.codec },
                |m: &mut AppDescriptor| { &mut m.codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigurationDescriptor>>(
                "configuration",
                |m: &AppDescriptor| { &m.configuration },
                |m: &mut AppDescriptor| { &mut m.configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryServicesDescriptor>>(
                "query_services",
                |m: &AppDescriptor| { &m.query_services },
                |m: &mut AppDescriptor| { &mut m.query_services },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxDescriptor>>(
                "tx",
                |m: &AppDescriptor| { &m.tx },
                |m: &mut AppDescriptor| { &mut m.tx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDescriptor>(
                "AppDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDescriptor {
        static instance: ::protobuf::rt::LazyV2<AppDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDescriptor::new)
    }
}

impl ::protobuf::Clear for AppDescriptor {
    fn clear(&mut self) {
        self.authn.clear();
        self.chain.clear();
        self.codec.clear();
        self.configuration.clear();
        self.query_services.clear();
        self.tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxDescriptor {
    // message fields
    pub fullname: ::std::string::String,
    pub msgs: ::protobuf::RepeatedField<MsgDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxDescriptor {
    fn default() -> &'a TxDescriptor {
        <TxDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl TxDescriptor {
    pub fn new() -> TxDescriptor {
        ::std::default::Default::default()
    }

    // string fullname = 1;


    pub fn get_fullname(&self) -> &str {
        &self.fullname
    }
    pub fn clear_fullname(&mut self) {
        self.fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullname(&mut self, v: ::std::string::String) {
        self.fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.fullname
    }

    // Take field
    pub fn take_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullname, ::std::string::String::new())
    }

    // repeated .cosmos.base.reflection.v2alpha1.MsgDescriptor msgs = 2;


    pub fn get_msgs(&self) -> &[MsgDescriptor] {
        &self.msgs
    }
    pub fn clear_msgs(&mut self) {
        self.msgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_msgs(&mut self, v: ::protobuf::RepeatedField<MsgDescriptor>) {
        self.msgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_msgs(&mut self) -> &mut ::protobuf::RepeatedField<MsgDescriptor> {
        &mut self.msgs
    }

    // Take field
    pub fn take_msgs(&mut self) -> ::protobuf::RepeatedField<MsgDescriptor> {
        ::std::mem::replace(&mut self.msgs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.msgs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.msgs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.msgs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxDescriptor {
        TxDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullname",
                |m: &TxDescriptor| { &m.fullname },
                |m: &mut TxDescriptor| { &mut m.fullname },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MsgDescriptor>>(
                "msgs",
                |m: &TxDescriptor| { &m.msgs },
                |m: &mut TxDescriptor| { &mut m.msgs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxDescriptor>(
                "TxDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TxDescriptor {
        static instance: ::protobuf::rt::LazyV2<TxDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxDescriptor::new)
    }
}

impl ::protobuf::Clear for TxDescriptor {
    fn clear(&mut self) {
        self.fullname.clear();
        self.msgs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthnDescriptor {
    // message fields
    pub sign_modes: ::protobuf::RepeatedField<SigningModeDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthnDescriptor {
    fn default() -> &'a AuthnDescriptor {
        <AuthnDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl AuthnDescriptor {
    pub fn new() -> AuthnDescriptor {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes = 1;


    pub fn get_sign_modes(&self) -> &[SigningModeDescriptor] {
        &self.sign_modes
    }
    pub fn clear_sign_modes(&mut self) {
        self.sign_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign_modes(&mut self, v: ::protobuf::RepeatedField<SigningModeDescriptor>) {
        self.sign_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sign_modes(&mut self) -> &mut ::protobuf::RepeatedField<SigningModeDescriptor> {
        &mut self.sign_modes
    }

    // Take field
    pub fn take_sign_modes(&mut self) -> ::protobuf::RepeatedField<SigningModeDescriptor> {
        ::std::mem::replace(&mut self.sign_modes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthnDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.sign_modes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sign_modes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sign_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sign_modes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthnDescriptor {
        AuthnDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SigningModeDescriptor>>(
                "sign_modes",
                |m: &AuthnDescriptor| { &m.sign_modes },
                |m: &mut AuthnDescriptor| { &mut m.sign_modes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthnDescriptor>(
                "AuthnDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthnDescriptor {
        static instance: ::protobuf::rt::LazyV2<AuthnDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthnDescriptor::new)
    }
}

impl ::protobuf::Clear for AuthnDescriptor {
    fn clear(&mut self) {
        self.sign_modes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthnDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthnDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SigningModeDescriptor {
    // message fields
    pub name: ::std::string::String,
    pub number: i32,
    pub authn_info_provider_method_fullname: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SigningModeDescriptor {
    fn default() -> &'a SigningModeDescriptor {
        <SigningModeDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl SigningModeDescriptor {
    pub fn new() -> SigningModeDescriptor {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 number = 2;


    pub fn get_number(&self) -> i32 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = v;
    }

    // string authn_info_provider_method_fullname = 3;


    pub fn get_authn_info_provider_method_fullname(&self) -> &str {
        &self.authn_info_provider_method_fullname
    }
    pub fn clear_authn_info_provider_method_fullname(&mut self) {
        self.authn_info_provider_method_fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_authn_info_provider_method_fullname(&mut self, v: ::std::string::String) {
        self.authn_info_provider_method_fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authn_info_provider_method_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.authn_info_provider_method_fullname
    }

    // Take field
    pub fn take_authn_info_provider_method_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authn_info_provider_method_fullname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SigningModeDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authn_info_provider_method_fullname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.authn_info_provider_method_fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.authn_info_provider_method_fullname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.number != 0 {
            os.write_int32(2, self.number)?;
        }
        if !self.authn_info_provider_method_fullname.is_empty() {
            os.write_string(3, &self.authn_info_provider_method_fullname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SigningModeDescriptor {
        SigningModeDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SigningModeDescriptor| { &m.name },
                |m: &mut SigningModeDescriptor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "number",
                |m: &SigningModeDescriptor| { &m.number },
                |m: &mut SigningModeDescriptor| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authn_info_provider_method_fullname",
                |m: &SigningModeDescriptor| { &m.authn_info_provider_method_fullname },
                |m: &mut SigningModeDescriptor| { &mut m.authn_info_provider_method_fullname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SigningModeDescriptor>(
                "SigningModeDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SigningModeDescriptor {
        static instance: ::protobuf::rt::LazyV2<SigningModeDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SigningModeDescriptor::new)
    }
}

impl ::protobuf::Clear for SigningModeDescriptor {
    fn clear(&mut self) {
        self.name.clear();
        self.number = 0;
        self.authn_info_provider_method_fullname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SigningModeDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigningModeDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainDescriptor {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainDescriptor {
    fn default() -> &'a ChainDescriptor {
        <ChainDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ChainDescriptor {
    pub fn new() -> ChainDescriptor {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChainDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainDescriptor {
        ChainDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ChainDescriptor| { &m.id },
                |m: &mut ChainDescriptor| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainDescriptor>(
                "ChainDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainDescriptor {
        static instance: ::protobuf::rt::LazyV2<ChainDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainDescriptor::new)
    }
}

impl ::protobuf::Clear for ChainDescriptor {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodecDescriptor {
    // message fields
    pub interfaces: ::protobuf::RepeatedField<InterfaceDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodecDescriptor {
    fn default() -> &'a CodecDescriptor {
        <CodecDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl CodecDescriptor {
    pub fn new() -> CodecDescriptor {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces = 1;


    pub fn get_interfaces(&self) -> &[InterfaceDescriptor] {
        &self.interfaces
    }
    pub fn clear_interfaces(&mut self) {
        self.interfaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_interfaces(&mut self, v: ::protobuf::RepeatedField<InterfaceDescriptor>) {
        self.interfaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interfaces(&mut self) -> &mut ::protobuf::RepeatedField<InterfaceDescriptor> {
        &mut self.interfaces
    }

    // Take field
    pub fn take_interfaces(&mut self) -> ::protobuf::RepeatedField<InterfaceDescriptor> {
        ::std::mem::replace(&mut self.interfaces, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CodecDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.interfaces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interfaces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.interfaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.interfaces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodecDescriptor {
        CodecDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceDescriptor>>(
                "interfaces",
                |m: &CodecDescriptor| { &m.interfaces },
                |m: &mut CodecDescriptor| { &mut m.interfaces },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodecDescriptor>(
                "CodecDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CodecDescriptor {
        static instance: ::protobuf::rt::LazyV2<CodecDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CodecDescriptor::new)
    }
}

impl ::protobuf::Clear for CodecDescriptor {
    fn clear(&mut self) {
        self.interfaces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodecDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodecDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InterfaceDescriptor {
    // message fields
    pub fullname: ::std::string::String,
    pub interface_accepting_messages: ::protobuf::RepeatedField<InterfaceAcceptingMessageDescriptor>,
    pub interface_implementers: ::protobuf::RepeatedField<InterfaceImplementerDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterfaceDescriptor {
    fn default() -> &'a InterfaceDescriptor {
        <InterfaceDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceDescriptor {
    pub fn new() -> InterfaceDescriptor {
        ::std::default::Default::default()
    }

    // string fullname = 1;


    pub fn get_fullname(&self) -> &str {
        &self.fullname
    }
    pub fn clear_fullname(&mut self) {
        self.fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullname(&mut self, v: ::std::string::String) {
        self.fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.fullname
    }

    // Take field
    pub fn take_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullname, ::std::string::String::new())
    }

    // repeated .cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages = 2;


    pub fn get_interface_accepting_messages(&self) -> &[InterfaceAcceptingMessageDescriptor] {
        &self.interface_accepting_messages
    }
    pub fn clear_interface_accepting_messages(&mut self) {
        self.interface_accepting_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface_accepting_messages(&mut self, v: ::protobuf::RepeatedField<InterfaceAcceptingMessageDescriptor>) {
        self.interface_accepting_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interface_accepting_messages(&mut self) -> &mut ::protobuf::RepeatedField<InterfaceAcceptingMessageDescriptor> {
        &mut self.interface_accepting_messages
    }

    // Take field
    pub fn take_interface_accepting_messages(&mut self) -> ::protobuf::RepeatedField<InterfaceAcceptingMessageDescriptor> {
        ::std::mem::replace(&mut self.interface_accepting_messages, ::protobuf::RepeatedField::new())
    }

    // repeated .cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers = 3;


    pub fn get_interface_implementers(&self) -> &[InterfaceImplementerDescriptor] {
        &self.interface_implementers
    }
    pub fn clear_interface_implementers(&mut self) {
        self.interface_implementers.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface_implementers(&mut self, v: ::protobuf::RepeatedField<InterfaceImplementerDescriptor>) {
        self.interface_implementers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interface_implementers(&mut self) -> &mut ::protobuf::RepeatedField<InterfaceImplementerDescriptor> {
        &mut self.interface_implementers
    }

    // Take field
    pub fn take_interface_implementers(&mut self) -> ::protobuf::RepeatedField<InterfaceImplementerDescriptor> {
        ::std::mem::replace(&mut self.interface_implementers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InterfaceDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.interface_accepting_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interface_implementers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interface_accepting_messages)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interface_implementers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.interface_accepting_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.interface_implementers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.interface_accepting_messages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.interface_implementers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterfaceDescriptor {
        InterfaceDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullname",
                |m: &InterfaceDescriptor| { &m.fullname },
                |m: &mut InterfaceDescriptor| { &mut m.fullname },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceAcceptingMessageDescriptor>>(
                "interface_accepting_messages",
                |m: &InterfaceDescriptor| { &m.interface_accepting_messages },
                |m: &mut InterfaceDescriptor| { &mut m.interface_accepting_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceImplementerDescriptor>>(
                "interface_implementers",
                |m: &InterfaceDescriptor| { &m.interface_implementers },
                |m: &mut InterfaceDescriptor| { &mut m.interface_implementers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterfaceDescriptor>(
                "InterfaceDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterfaceDescriptor {
        static instance: ::protobuf::rt::LazyV2<InterfaceDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterfaceDescriptor::new)
    }
}

impl ::protobuf::Clear for InterfaceDescriptor {
    fn clear(&mut self) {
        self.fullname.clear();
        self.interface_accepting_messages.clear();
        self.interface_implementers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterfaceDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InterfaceImplementerDescriptor {
    // message fields
    pub fullname: ::std::string::String,
    pub type_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterfaceImplementerDescriptor {
    fn default() -> &'a InterfaceImplementerDescriptor {
        <InterfaceImplementerDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceImplementerDescriptor {
    pub fn new() -> InterfaceImplementerDescriptor {
        ::std::default::Default::default()
    }

    // string fullname = 1;


    pub fn get_fullname(&self) -> &str {
        &self.fullname
    }
    pub fn clear_fullname(&mut self) {
        self.fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullname(&mut self, v: ::std::string::String) {
        self.fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.fullname
    }

    // Take field
    pub fn take_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullname, ::std::string::String::new())
    }

    // string type_url = 2;


    pub fn get_type_url(&self) -> &str {
        &self.type_url
    }
    pub fn clear_type_url(&mut self) {
        self.type_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_url(&mut self, v: ::std::string::String) {
        self.type_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_url(&mut self) -> &mut ::std::string::String {
        &mut self.type_url
    }

    // Take field
    pub fn take_type_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InterfaceImplementerDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        if !self.type_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        if !self.type_url.is_empty() {
            os.write_string(2, &self.type_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterfaceImplementerDescriptor {
        InterfaceImplementerDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullname",
                |m: &InterfaceImplementerDescriptor| { &m.fullname },
                |m: &mut InterfaceImplementerDescriptor| { &mut m.fullname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type_url",
                |m: &InterfaceImplementerDescriptor| { &m.type_url },
                |m: &mut InterfaceImplementerDescriptor| { &mut m.type_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterfaceImplementerDescriptor>(
                "InterfaceImplementerDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterfaceImplementerDescriptor {
        static instance: ::protobuf::rt::LazyV2<InterfaceImplementerDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterfaceImplementerDescriptor::new)
    }
}

impl ::protobuf::Clear for InterfaceImplementerDescriptor {
    fn clear(&mut self) {
        self.fullname.clear();
        self.type_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterfaceImplementerDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceImplementerDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InterfaceAcceptingMessageDescriptor {
    // message fields
    pub fullname: ::std::string::String,
    pub field_descriptor_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterfaceAcceptingMessageDescriptor {
    fn default() -> &'a InterfaceAcceptingMessageDescriptor {
        <InterfaceAcceptingMessageDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceAcceptingMessageDescriptor {
    pub fn new() -> InterfaceAcceptingMessageDescriptor {
        ::std::default::Default::default()
    }

    // string fullname = 1;


    pub fn get_fullname(&self) -> &str {
        &self.fullname
    }
    pub fn clear_fullname(&mut self) {
        self.fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullname(&mut self, v: ::std::string::String) {
        self.fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.fullname
    }

    // Take field
    pub fn take_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullname, ::std::string::String::new())
    }

    // repeated string field_descriptor_names = 2;


    pub fn get_field_descriptor_names(&self) -> &[::std::string::String] {
        &self.field_descriptor_names
    }
    pub fn clear_field_descriptor_names(&mut self) {
        self.field_descriptor_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_descriptor_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.field_descriptor_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_descriptor_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.field_descriptor_names
    }

    // Take field
    pub fn take_field_descriptor_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.field_descriptor_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InterfaceAcceptingMessageDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.field_descriptor_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        for value in &self.field_descriptor_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        for v in &self.field_descriptor_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterfaceAcceptingMessageDescriptor {
        InterfaceAcceptingMessageDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullname",
                |m: &InterfaceAcceptingMessageDescriptor| { &m.fullname },
                |m: &mut InterfaceAcceptingMessageDescriptor| { &mut m.fullname },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "field_descriptor_names",
                |m: &InterfaceAcceptingMessageDescriptor| { &m.field_descriptor_names },
                |m: &mut InterfaceAcceptingMessageDescriptor| { &mut m.field_descriptor_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterfaceAcceptingMessageDescriptor>(
                "InterfaceAcceptingMessageDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterfaceAcceptingMessageDescriptor {
        static instance: ::protobuf::rt::LazyV2<InterfaceAcceptingMessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterfaceAcceptingMessageDescriptor::new)
    }
}

impl ::protobuf::Clear for InterfaceAcceptingMessageDescriptor {
    fn clear(&mut self) {
        self.fullname.clear();
        self.field_descriptor_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterfaceAcceptingMessageDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceAcceptingMessageDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigurationDescriptor {
    // message fields
    pub bech32_account_address_prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigurationDescriptor {
    fn default() -> &'a ConfigurationDescriptor {
        <ConfigurationDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationDescriptor {
    pub fn new() -> ConfigurationDescriptor {
        ::std::default::Default::default()
    }

    // string bech32_account_address_prefix = 1;


    pub fn get_bech32_account_address_prefix(&self) -> &str {
        &self.bech32_account_address_prefix
    }
    pub fn clear_bech32_account_address_prefix(&mut self) {
        self.bech32_account_address_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_bech32_account_address_prefix(&mut self, v: ::std::string::String) {
        self.bech32_account_address_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bech32_account_address_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.bech32_account_address_prefix
    }

    // Take field
    pub fn take_bech32_account_address_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bech32_account_address_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfigurationDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bech32_account_address_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bech32_account_address_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bech32_account_address_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bech32_account_address_prefix.is_empty() {
            os.write_string(1, &self.bech32_account_address_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigurationDescriptor {
        ConfigurationDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bech32_account_address_prefix",
                |m: &ConfigurationDescriptor| { &m.bech32_account_address_prefix },
                |m: &mut ConfigurationDescriptor| { &mut m.bech32_account_address_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigurationDescriptor>(
                "ConfigurationDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigurationDescriptor {
        static instance: ::protobuf::rt::LazyV2<ConfigurationDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigurationDescriptor::new)
    }
}

impl ::protobuf::Clear for ConfigurationDescriptor {
    fn clear(&mut self) {
        self.bech32_account_address_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigurationDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgDescriptor {
    // message fields
    pub msg_type_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgDescriptor {
    fn default() -> &'a MsgDescriptor {
        <MsgDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl MsgDescriptor {
    pub fn new() -> MsgDescriptor {
        ::std::default::Default::default()
    }

    // string msg_type_url = 1;


    pub fn get_msg_type_url(&self) -> &str {
        &self.msg_type_url
    }
    pub fn clear_msg_type_url(&mut self) {
        self.msg_type_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg_type_url(&mut self, v: ::std::string::String) {
        self.msg_type_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_type_url(&mut self) -> &mut ::std::string::String {
        &mut self.msg_type_url
    }

    // Take field
    pub fn take_msg_type_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.msg_type_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.msg_type_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg_type_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.msg_type_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.msg_type_url.is_empty() {
            os.write_string(1, &self.msg_type_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgDescriptor {
        MsgDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg_type_url",
                |m: &MsgDescriptor| { &m.msg_type_url },
                |m: &mut MsgDescriptor| { &mut m.msg_type_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgDescriptor>(
                "MsgDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgDescriptor {
        static instance: ::protobuf::rt::LazyV2<MsgDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgDescriptor::new)
    }
}

impl ::protobuf::Clear for MsgDescriptor {
    fn clear(&mut self) {
        self.msg_type_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAuthnDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAuthnDescriptorRequest {
    fn default() -> &'a GetAuthnDescriptorRequest {
        <GetAuthnDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthnDescriptorRequest {
    pub fn new() -> GetAuthnDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAuthnDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAuthnDescriptorRequest {
        GetAuthnDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAuthnDescriptorRequest>(
                "GetAuthnDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAuthnDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetAuthnDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAuthnDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetAuthnDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAuthnDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthnDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAuthnDescriptorResponse {
    // message fields
    pub authn: ::protobuf::SingularPtrField<AuthnDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAuthnDescriptorResponse {
    fn default() -> &'a GetAuthnDescriptorResponse {
        <GetAuthnDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthnDescriptorResponse {
    pub fn new() -> GetAuthnDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;


    pub fn get_authn(&self) -> &AuthnDescriptor {
        self.authn.as_ref().unwrap_or_else(|| <AuthnDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authn(&mut self) {
        self.authn.clear();
    }

    pub fn has_authn(&self) -> bool {
        self.authn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authn(&mut self, v: AuthnDescriptor) {
        self.authn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authn(&mut self) -> &mut AuthnDescriptor {
        if self.authn.is_none() {
            self.authn.set_default();
        }
        self.authn.as_mut().unwrap()
    }

    // Take field
    pub fn take_authn(&mut self) -> AuthnDescriptor {
        self.authn.take().unwrap_or_else(|| AuthnDescriptor::new())
    }
}

impl ::protobuf::Message for GetAuthnDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.authn {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authn.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAuthnDescriptorResponse {
        GetAuthnDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthnDescriptor>>(
                "authn",
                |m: &GetAuthnDescriptorResponse| { &m.authn },
                |m: &mut GetAuthnDescriptorResponse| { &mut m.authn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAuthnDescriptorResponse>(
                "GetAuthnDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAuthnDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetAuthnDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAuthnDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetAuthnDescriptorResponse {
    fn clear(&mut self) {
        self.authn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAuthnDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthnDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetChainDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetChainDescriptorRequest {
    fn default() -> &'a GetChainDescriptorRequest {
        <GetChainDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetChainDescriptorRequest {
    pub fn new() -> GetChainDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetChainDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetChainDescriptorRequest {
        GetChainDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetChainDescriptorRequest>(
                "GetChainDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetChainDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetChainDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetChainDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetChainDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetChainDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChainDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetChainDescriptorResponse {
    // message fields
    pub chain: ::protobuf::SingularPtrField<ChainDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetChainDescriptorResponse {
    fn default() -> &'a GetChainDescriptorResponse {
        <GetChainDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetChainDescriptorResponse {
    pub fn new() -> GetChainDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 1;


    pub fn get_chain(&self) -> &ChainDescriptor {
        self.chain.as_ref().unwrap_or_else(|| <ChainDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chain(&mut self) {
        self.chain.clear();
    }

    pub fn has_chain(&self) -> bool {
        self.chain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: ChainDescriptor) {
        self.chain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain(&mut self) -> &mut ChainDescriptor {
        if self.chain.is_none() {
            self.chain.set_default();
        }
        self.chain.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain(&mut self) -> ChainDescriptor {
        self.chain.take().unwrap_or_else(|| ChainDescriptor::new())
    }
}

impl ::protobuf::Message for GetChainDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.chain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chain.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetChainDescriptorResponse {
        GetChainDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainDescriptor>>(
                "chain",
                |m: &GetChainDescriptorResponse| { &m.chain },
                |m: &mut GetChainDescriptorResponse| { &mut m.chain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetChainDescriptorResponse>(
                "GetChainDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetChainDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetChainDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetChainDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetChainDescriptorResponse {
    fn clear(&mut self) {
        self.chain.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetChainDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChainDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCodecDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCodecDescriptorRequest {
    fn default() -> &'a GetCodecDescriptorRequest {
        <GetCodecDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCodecDescriptorRequest {
    pub fn new() -> GetCodecDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCodecDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCodecDescriptorRequest {
        GetCodecDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCodecDescriptorRequest>(
                "GetCodecDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCodecDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetCodecDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCodecDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetCodecDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCodecDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCodecDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCodecDescriptorResponse {
    // message fields
    pub codec: ::protobuf::SingularPtrField<CodecDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCodecDescriptorResponse {
    fn default() -> &'a GetCodecDescriptorResponse {
        <GetCodecDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCodecDescriptorResponse {
    pub fn new() -> GetCodecDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 1;


    pub fn get_codec(&self) -> &CodecDescriptor {
        self.codec.as_ref().unwrap_or_else(|| <CodecDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_codec(&mut self) {
        self.codec.clear();
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: CodecDescriptor) {
        self.codec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut CodecDescriptor {
        if self.codec.is_none() {
            self.codec.set_default();
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> CodecDescriptor {
        self.codec.take().unwrap_or_else(|| CodecDescriptor::new())
    }
}

impl ::protobuf::Message for GetCodecDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.codec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.codec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.codec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.codec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCodecDescriptorResponse {
        GetCodecDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodecDescriptor>>(
                "codec",
                |m: &GetCodecDescriptorResponse| { &m.codec },
                |m: &mut GetCodecDescriptorResponse| { &mut m.codec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCodecDescriptorResponse>(
                "GetCodecDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCodecDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetCodecDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCodecDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetCodecDescriptorResponse {
    fn clear(&mut self) {
        self.codec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCodecDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCodecDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConfigurationDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConfigurationDescriptorRequest {
    fn default() -> &'a GetConfigurationDescriptorRequest {
        <GetConfigurationDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConfigurationDescriptorRequest {
    pub fn new() -> GetConfigurationDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetConfigurationDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConfigurationDescriptorRequest {
        GetConfigurationDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConfigurationDescriptorRequest>(
                "GetConfigurationDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConfigurationDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetConfigurationDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConfigurationDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetConfigurationDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConfigurationDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConfigurationDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConfigurationDescriptorResponse {
    // message fields
    pub config: ::protobuf::SingularPtrField<ConfigurationDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConfigurationDescriptorResponse {
    fn default() -> &'a GetConfigurationDescriptorResponse {
        <GetConfigurationDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConfigurationDescriptorResponse {
    pub fn new() -> GetConfigurationDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config = 1;


    pub fn get_config(&self) -> &ConfigurationDescriptor {
        self.config.as_ref().unwrap_or_else(|| <ConfigurationDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ConfigurationDescriptor) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ConfigurationDescriptor {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ConfigurationDescriptor {
        self.config.take().unwrap_or_else(|| ConfigurationDescriptor::new())
    }
}

impl ::protobuf::Message for GetConfigurationDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConfigurationDescriptorResponse {
        GetConfigurationDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigurationDescriptor>>(
                "config",
                |m: &GetConfigurationDescriptorResponse| { &m.config },
                |m: &mut GetConfigurationDescriptorResponse| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConfigurationDescriptorResponse>(
                "GetConfigurationDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConfigurationDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetConfigurationDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConfigurationDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetConfigurationDescriptorResponse {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConfigurationDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConfigurationDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQueryServicesDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQueryServicesDescriptorRequest {
    fn default() -> &'a GetQueryServicesDescriptorRequest {
        <GetQueryServicesDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetQueryServicesDescriptorRequest {
    pub fn new() -> GetQueryServicesDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetQueryServicesDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQueryServicesDescriptorRequest {
        GetQueryServicesDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetQueryServicesDescriptorRequest>(
                "GetQueryServicesDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetQueryServicesDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetQueryServicesDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetQueryServicesDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetQueryServicesDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQueryServicesDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQueryServicesDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQueryServicesDescriptorResponse {
    // message fields
    pub queries: ::protobuf::SingularPtrField<QueryServicesDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQueryServicesDescriptorResponse {
    fn default() -> &'a GetQueryServicesDescriptorResponse {
        <GetQueryServicesDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetQueryServicesDescriptorResponse {
    pub fn new() -> GetQueryServicesDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries = 1;


    pub fn get_queries(&self) -> &QueryServicesDescriptor {
        self.queries.as_ref().unwrap_or_else(|| <QueryServicesDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_queries(&mut self) {
        self.queries.clear();
    }

    pub fn has_queries(&self) -> bool {
        self.queries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queries(&mut self, v: QueryServicesDescriptor) {
        self.queries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queries(&mut self) -> &mut QueryServicesDescriptor {
        if self.queries.is_none() {
            self.queries.set_default();
        }
        self.queries.as_mut().unwrap()
    }

    // Take field
    pub fn take_queries(&mut self) -> QueryServicesDescriptor {
        self.queries.take().unwrap_or_else(|| QueryServicesDescriptor::new())
    }
}

impl ::protobuf::Message for GetQueryServicesDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.queries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.queries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.queries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.queries.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQueryServicesDescriptorResponse {
        GetQueryServicesDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryServicesDescriptor>>(
                "queries",
                |m: &GetQueryServicesDescriptorResponse| { &m.queries },
                |m: &mut GetQueryServicesDescriptorResponse| { &mut m.queries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetQueryServicesDescriptorResponse>(
                "GetQueryServicesDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetQueryServicesDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetQueryServicesDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetQueryServicesDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetQueryServicesDescriptorResponse {
    fn clear(&mut self) {
        self.queries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQueryServicesDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQueryServicesDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTxDescriptorRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxDescriptorRequest {
    fn default() -> &'a GetTxDescriptorRequest {
        <GetTxDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTxDescriptorRequest {
    pub fn new() -> GetTxDescriptorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTxDescriptorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxDescriptorRequest {
        GetTxDescriptorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTxDescriptorRequest>(
                "GetTxDescriptorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTxDescriptorRequest {
        static instance: ::protobuf::rt::LazyV2<GetTxDescriptorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxDescriptorRequest::new)
    }
}

impl ::protobuf::Clear for GetTxDescriptorRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTxDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxDescriptorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTxDescriptorResponse {
    // message fields
    pub tx: ::protobuf::SingularPtrField<TxDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxDescriptorResponse {
    fn default() -> &'a GetTxDescriptorResponse {
        <GetTxDescriptorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTxDescriptorResponse {
    pub fn new() -> GetTxDescriptorResponse {
        ::std::default::Default::default()
    }

    // .cosmos.base.reflection.v2alpha1.TxDescriptor tx = 1;


    pub fn get_tx(&self) -> &TxDescriptor {
        self.tx.as_ref().unwrap_or_else(|| <TxDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    pub fn has_tx(&self) -> bool {
        self.tx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: TxDescriptor) {
        self.tx = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx(&mut self) -> &mut TxDescriptor {
        if self.tx.is_none() {
            self.tx.set_default();
        }
        self.tx.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx(&mut self) -> TxDescriptor {
        self.tx.take().unwrap_or_else(|| TxDescriptor::new())
    }
}

impl ::protobuf::Message for GetTxDescriptorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tx.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxDescriptorResponse {
        GetTxDescriptorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxDescriptor>>(
                "tx",
                |m: &GetTxDescriptorResponse| { &m.tx },
                |m: &mut GetTxDescriptorResponse| { &mut m.tx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTxDescriptorResponse>(
                "GetTxDescriptorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTxDescriptorResponse {
        static instance: ::protobuf::rt::LazyV2<GetTxDescriptorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxDescriptorResponse::new)
    }
}

impl ::protobuf::Clear for GetTxDescriptorResponse {
    fn clear(&mut self) {
        self.tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTxDescriptorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxDescriptorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryServicesDescriptor {
    // message fields
    pub query_services: ::protobuf::RepeatedField<QueryServiceDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryServicesDescriptor {
    fn default() -> &'a QueryServicesDescriptor {
        <QueryServicesDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryServicesDescriptor {
    pub fn new() -> QueryServicesDescriptor {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services = 1;


    pub fn get_query_services(&self) -> &[QueryServiceDescriptor] {
        &self.query_services
    }
    pub fn clear_query_services(&mut self) {
        self.query_services.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_services(&mut self, v: ::protobuf::RepeatedField<QueryServiceDescriptor>) {
        self.query_services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_services(&mut self) -> &mut ::protobuf::RepeatedField<QueryServiceDescriptor> {
        &mut self.query_services
    }

    // Take field
    pub fn take_query_services(&mut self) -> ::protobuf::RepeatedField<QueryServiceDescriptor> {
        ::std::mem::replace(&mut self.query_services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryServicesDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.query_services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query_services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.query_services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.query_services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryServicesDescriptor {
        QueryServicesDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryServiceDescriptor>>(
                "query_services",
                |m: &QueryServicesDescriptor| { &m.query_services },
                |m: &mut QueryServicesDescriptor| { &mut m.query_services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryServicesDescriptor>(
                "QueryServicesDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryServicesDescriptor {
        static instance: ::protobuf::rt::LazyV2<QueryServicesDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryServicesDescriptor::new)
    }
}

impl ::protobuf::Clear for QueryServicesDescriptor {
    fn clear(&mut self) {
        self.query_services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryServicesDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryServicesDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryServiceDescriptor {
    // message fields
    pub fullname: ::std::string::String,
    pub is_module: bool,
    pub methods: ::protobuf::RepeatedField<QueryMethodDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryServiceDescriptor {
    fn default() -> &'a QueryServiceDescriptor {
        <QueryServiceDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryServiceDescriptor {
    pub fn new() -> QueryServiceDescriptor {
        ::std::default::Default::default()
    }

    // string fullname = 1;


    pub fn get_fullname(&self) -> &str {
        &self.fullname
    }
    pub fn clear_fullname(&mut self) {
        self.fullname.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullname(&mut self, v: ::std::string::String) {
        self.fullname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullname(&mut self) -> &mut ::std::string::String {
        &mut self.fullname
    }

    // Take field
    pub fn take_fullname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullname, ::std::string::String::new())
    }

    // bool is_module = 2;


    pub fn get_is_module(&self) -> bool {
        self.is_module
    }
    pub fn clear_is_module(&mut self) {
        self.is_module = false;
    }

    // Param is passed by value, moved
    pub fn set_is_module(&mut self, v: bool) {
        self.is_module = v;
    }

    // repeated .cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods = 3;


    pub fn get_methods(&self) -> &[QueryMethodDescriptor] {
        &self.methods
    }
    pub fn clear_methods(&mut self) {
        self.methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_methods(&mut self, v: ::protobuf::RepeatedField<QueryMethodDescriptor>) {
        self.methods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_methods(&mut self) -> &mut ::protobuf::RepeatedField<QueryMethodDescriptor> {
        &mut self.methods
    }

    // Take field
    pub fn take_methods(&mut self) -> ::protobuf::RepeatedField<QueryMethodDescriptor> {
        ::std::mem::replace(&mut self.methods, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryServiceDescriptor {
    fn is_initialized(&self) -> bool {
        for v in &self.methods {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullname)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_module = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.methods)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fullname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fullname);
        }
        if self.is_module != false {
            my_size += 2;
        }
        for value in &self.methods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fullname.is_empty() {
            os.write_string(1, &self.fullname)?;
        }
        if self.is_module != false {
            os.write_bool(2, self.is_module)?;
        }
        for v in &self.methods {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryServiceDescriptor {
        QueryServiceDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullname",
                |m: &QueryServiceDescriptor| { &m.fullname },
                |m: &mut QueryServiceDescriptor| { &mut m.fullname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_module",
                |m: &QueryServiceDescriptor| { &m.is_module },
                |m: &mut QueryServiceDescriptor| { &mut m.is_module },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryMethodDescriptor>>(
                "methods",
                |m: &QueryServiceDescriptor| { &m.methods },
                |m: &mut QueryServiceDescriptor| { &mut m.methods },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryServiceDescriptor>(
                "QueryServiceDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryServiceDescriptor {
        static instance: ::protobuf::rt::LazyV2<QueryServiceDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryServiceDescriptor::new)
    }
}

impl ::protobuf::Clear for QueryServiceDescriptor {
    fn clear(&mut self) {
        self.fullname.clear();
        self.is_module = false;
        self.methods.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryServiceDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryServiceDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryMethodDescriptor {
    // message fields
    pub name: ::std::string::String,
    pub full_query_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMethodDescriptor {
    fn default() -> &'a QueryMethodDescriptor {
        <QueryMethodDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl QueryMethodDescriptor {
    pub fn new() -> QueryMethodDescriptor {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string full_query_path = 2;


    pub fn get_full_query_path(&self) -> &str {
        &self.full_query_path
    }
    pub fn clear_full_query_path(&mut self) {
        self.full_query_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_query_path(&mut self, v: ::std::string::String) {
        self.full_query_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_query_path(&mut self) -> &mut ::std::string::String {
        &mut self.full_query_path
    }

    // Take field
    pub fn take_full_query_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_query_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMethodDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_query_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.full_query_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.full_query_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.full_query_path.is_empty() {
            os.write_string(2, &self.full_query_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMethodDescriptor {
        QueryMethodDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QueryMethodDescriptor| { &m.name },
                |m: &mut QueryMethodDescriptor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "full_query_path",
                |m: &QueryMethodDescriptor| { &m.full_query_path },
                |m: &mut QueryMethodDescriptor| { &mut m.full_query_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryMethodDescriptor>(
                "QueryMethodDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryMethodDescriptor {
        static instance: ::protobuf::rt::LazyV2<QueryMethodDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMethodDescriptor::new)
    }
}

impl ::protobuf::Clear for QueryMethodDescriptor {
    fn clear(&mut self) {
        self.name.clear();
        self.full_query_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryMethodDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMethodDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n0cosmos/base/reflection/v2alpha1/reflection.proto\x12\x1fcosmos.base.r\
    eflection.v2alpha1\x1a\x1cgoogle/api/annotations.proto\"\xe7\x03\n\rAppD\
    escriptor\x12F\n\x05authn\x18\x01\x20\x01(\x0b20.cosmos.base.reflection.\
    v2alpha1.AuthnDescriptorR\x05authn\x12F\n\x05chain\x18\x02\x20\x01(\x0b2\
    0.cosmos.base.reflection.v2alpha1.ChainDescriptorR\x05chain\x12F\n\x05co\
    dec\x18\x03\x20\x01(\x0b20.cosmos.base.reflection.v2alpha1.CodecDescript\
    orR\x05codec\x12^\n\rconfiguration\x18\x04\x20\x01(\x0b28.cosmos.base.re\
    flection.v2alpha1.ConfigurationDescriptorR\rconfiguration\x12_\n\x0equer\
    y_services\x18\x05\x20\x01(\x0b28.cosmos.base.reflection.v2alpha1.QueryS\
    ervicesDescriptorR\rqueryServices\x12=\n\x02tx\x18\x06\x20\x01(\x0b2-.co\
    smos.base.reflection.v2alpha1.TxDescriptorR\x02tx\"n\n\x0cTxDescriptor\
    \x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12B\n\x04msgs\
    \x18\x02\x20\x03(\x0b2..cosmos.base.reflection.v2alpha1.MsgDescriptorR\
    \x04msgs\"h\n\x0fAuthnDescriptor\x12U\n\nsign_modes\x18\x01\x20\x03(\x0b\
    26.cosmos.base.reflection.v2alpha1.SigningModeDescriptorR\tsignModes\"\
    \x91\x01\n\x15SigningModeDescriptor\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x16\n\x06number\x18\x02\x20\x01(\x05R\x06number\x12L\n#aut\
    hn_info_provider_method_fullname\x18\x03\x20\x01(\tR\x1fauthnInfoProvide\
    rMethodFullname\"!\n\x0fChainDescriptor\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\"g\n\x0fCodecDescriptor\x12T\n\ninterfaces\x18\x01\x20\x03(\
    \x0b24.cosmos.base.reflection.v2alpha1.InterfaceDescriptorR\ninterfaces\
    \"\xb2\x02\n\x13InterfaceDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\
    \x01(\tR\x08fullname\x12\x86\x01\n\x1cinterface_accepting_messages\x18\
    \x02\x20\x03(\x0b2D.cosmos.base.reflection.v2alpha1.InterfaceAcceptingMe\
    ssageDescriptorR\x1ainterfaceAcceptingMessages\x12v\n\x16interface_imple\
    menters\x18\x03\x20\x03(\x0b2?.cosmos.base.reflection.v2alpha1.Interface\
    ImplementerDescriptorR\x15interfaceImplementers\"W\n\x1eInterfaceImpleme\
    nterDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12\
    \x19\n\x08type_url\x18\x02\x20\x01(\tR\x07typeUrl\"w\n#InterfaceAcceptin\
    gMessageDescriptor\x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\
    \x124\n\x16field_descriptor_names\x18\x02\x20\x03(\tR\x14fieldDescriptor\
    Names\"\\\n\x17ConfigurationDescriptor\x12A\n\x1dbech32_account_address_\
    prefix\x18\x01\x20\x01(\tR\x1abech32AccountAddressPrefix\"1\n\rMsgDescri\
    ptor\x12\x20\n\x0cmsg_type_url\x18\x01\x20\x01(\tR\nmsgTypeUrl\"\x1b\n\
    \x19GetAuthnDescriptorRequest\"d\n\x1aGetAuthnDescriptorResponse\x12F\n\
    \x05authn\x18\x01\x20\x01(\x0b20.cosmos.base.reflection.v2alpha1.AuthnDe\
    scriptorR\x05authn\"\x1b\n\x19GetChainDescriptorRequest\"d\n\x1aGetChain\
    DescriptorResponse\x12F\n\x05chain\x18\x01\x20\x01(\x0b20.cosmos.base.re\
    flection.v2alpha1.ChainDescriptorR\x05chain\"\x1b\n\x19GetCodecDescripto\
    rRequest\"d\n\x1aGetCodecDescriptorResponse\x12F\n\x05codec\x18\x01\x20\
    \x01(\x0b20.cosmos.base.reflection.v2alpha1.CodecDescriptorR\x05codec\"#\
    \n!GetConfigurationDescriptorRequest\"v\n\"GetConfigurationDescriptorRes\
    ponse\x12P\n\x06config\x18\x01\x20\x01(\x0b28.cosmos.base.reflection.v2a\
    lpha1.ConfigurationDescriptorR\x06config\"#\n!GetQueryServicesDescriptor\
    Request\"x\n\"GetQueryServicesDescriptorResponse\x12R\n\x07queries\x18\
    \x01\x20\x01(\x0b28.cosmos.base.reflection.v2alpha1.QueryServicesDescrip\
    torR\x07queries\"\x18\n\x16GetTxDescriptorRequest\"X\n\x17GetTxDescripto\
    rResponse\x12=\n\x02tx\x18\x01\x20\x01(\x0b2-.cosmos.base.reflection.v2a\
    lpha1.TxDescriptorR\x02tx\"y\n\x17QueryServicesDescriptor\x12^\n\x0equer\
    y_services\x18\x01\x20\x03(\x0b27.cosmos.base.reflection.v2alpha1.QueryS\
    erviceDescriptorR\rqueryServices\"\xa3\x01\n\x16QueryServiceDescriptor\
    \x12\x1a\n\x08fullname\x18\x01\x20\x01(\tR\x08fullname\x12\x1b\n\tis_mod\
    ule\x18\x02\x20\x01(\x08R\x08isModule\x12P\n\x07methods\x18\x03\x20\x03(\
    \x0b26.cosmos.base.reflection.v2alpha1.QueryMethodDescriptorR\x07methods\
    \"S\n\x15QueryMethodDescriptor\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12&\n\x0ffull_query_path\x18\x02\x20\x01(\tR\rfullQueryPath2\xa7\n\
    \n\x11ReflectionService\x12\xcb\x01\n\x12GetAuthnDescriptor\x12:.cosmos.\
    base.reflection.v2alpha1.GetAuthnDescriptorRequest\x1a;.cosmos.base.refl\
    ection.v2alpha1.GetAuthnDescriptorResponse\"<\x82\xd3\xe4\x93\x026\x124/\
    cosmos/base/reflection/v1beta1/app_descriptor/authn\x12\xcb\x01\n\x12Get\
    ChainDescriptor\x12:.cosmos.base.reflection.v2alpha1.GetChainDescriptorR\
    equest\x1a;.cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse\"\
    <\x82\xd3\xe4\x93\x026\x124/cosmos/base/reflection/v1beta1/app_descripto\
    r/chain\x12\xcb\x01\n\x12GetCodecDescriptor\x12:.cosmos.base.reflection.\
    v2alpha1.GetCodecDescriptorRequest\x1a;.cosmos.base.reflection.v2alpha1.\
    GetCodecDescriptorResponse\"<\x82\xd3\xe4\x93\x026\x124/cosmos/base/refl\
    ection/v1beta1/app_descriptor/codec\x12\xeb\x01\n\x1aGetConfigurationDes\
    criptor\x12B.cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorR\
    equest\x1aC.cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRe\
    sponse\"D\x82\xd3\xe4\x93\x02>\x12</cosmos/base/reflection/v1beta1/app_d\
    escriptor/configuration\x12\xec\x01\n\x1aGetQueryServicesDescriptor\x12B\
    .cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest\x1aC.\
    cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse\"E\
    \x82\xd3\xe4\x93\x02?\x12=/cosmos/base/reflection/v1beta1/app_descriptor\
    /query_services\x12\xca\x01\n\x0fGetTxDescriptor\x127.cosmos.base.reflec\
    tion.v2alpha1.GetTxDescriptorRequest\x1a8.cosmos.base.reflection.v2alpha\
    1.GetTxDescriptorResponse\"D\x82\xd3\xe4\x93\x02>\x12</cosmos/base/refle\
    ction/v1beta1/app_descriptor/tx_descriptorB>Z<github.com/cosmos/cosmos-s\
    dk/server/grpc/reflection/v2alpha1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
